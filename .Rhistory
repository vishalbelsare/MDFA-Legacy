out <- cbind(round(arch.fit3@fit$coef,digits=6),c(0,psi2arch(psi))
colnames(out) <- c("MLE","Truth")
lik.arch(arch2psi(arch.fit3@fit$coef[2:(p+1)]),z.sim,Inf)
out <- cbind(round(arch.fit3@fit$coef,digits=6),c(0,psi2arch(psi)))
colnames(out) <- c("MLE","Truth")
label <- c("mu","alpha0")
for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) }
rownames(out) <- label
print(out)
set.seed(555)
T <- 2000
df <- 4
z.sim <- sim.arch(psi2arch(psi),T,rnorm(p),df)
plot(ts(z.sim))
lik.arch(psi,z.sim,df)
psi.init <- rep(0,p+2)
arch.fit <- optim(psi.init,lik.tarch,data=z.sim,method="BFGS")
print(arch.fit)
out <- cbind(c(psi2arch(arch.fit$par[1:(p+1)]),2+exp(arch.fit$par[p+2])),c(psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) }
label <- c(label,"df")
rownames(out) <- label
print(out)
arch.fit2 <- garch(z.sim, order = c(0, p))
lik.arch(arch2psi(arch.fit2$coef),z.sim,Inf)
out <- cbind(round(arch.fit2$coef,digits=6),psi2arch(psi))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) }
rownames(out) <- label
print(out)
set.seed(888)
p <- 1
q <- 5
psi <- rnorm(p+q+1)
out <- cbind(psi,psi2arch(psi),arch2psi(psi2arch(psi)))
colnames(out) <- c("psi","arch","psi")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
set.seed(222)
T <- 2000
df <- Inf
z.sim <- sim.garch(psi2arch(psi),T,rnorm(p),df)
plot(ts(z.sim))
lik.garch(psi,z.sim,p,df)
psi.init <- rep(0,p+q+1)
garch.fit <- optim(psi.init,fn=lik.garch,data=z.sim,p.order=p,df=Inf,method="BFGS")
print(garch.fit)
out <- cbind(round(psi2arch(garch.fit$par),digits=6),psi2arch(psi))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
garch.fit2 <- garch(z.sim, order = c(q, p))
lik.garch(arch2psi(garch.fit2$coef),z.sim,p,df=Inf)
out <- cbind(round(garch.fit2$coef,digits=6),psi2arch(psi))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
set.seed(444)
T <- 2000
df <- 5
z.sim <- sim.garch(psi2arch(psi),T,rnorm(p),df)
plot(ts(z.sim))
lik.garch(psi,z.sim,p,df)
psi.init <- rep(0,p+q+2)
garch.fit <- optim(psi.init,fn=lik.tgarch,data=z.sim,p.order=p,method="BFGS")
print(garch.fit)
out <- cbind(c(psi2arch(garch.fit$par[1:(p+q+1)]),2+exp(arch.fit$par[p+q+2])),c(psi2arch(psi),df))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
label <- c(label,"df")
rownames(out) <- label
print(out)
garch.fit2 <- garch(z.sim, order = c(q, p))
lik.garch(arch2psi(garch.fit2$coef),z.sim,p,df=Inf)
out <- cbind(round(garch.fit2$coef,digits=6),psi2arch(psi))
colnames(out) <- c("MLE","Truth")
label <- c("alpha0")
if(p > 0) { for(i in 1:p) { label <- c(label,paste("alpha",i,sep="")) } }
if(q > 0) { for(i in 1:q) { label <- c(label,paste("beta",i,sep="")) } }
rownames(out) <- label
print(out)
rep(1,2) %x% diag(3)
t(rep(1,2) %x% diag(3))
t(rep(1,2)) %x% diag(3)
test <- t(rep(1,2)) %x% diag(3)
test <- t(rep(1,2)) %x% matrix(seq(1,9),3,3)
test
matrix(seq(1,9),3,3)
array(test,c(3,3,2))
atest <- array(test,c(3,3,2))
help(lapply)
array_combine <- function(a_array,b_array)
{
N <- dim(a_array)[1]
len <- dim(a_array)[3]
c_array <- array(0,c(N,N,len))
for(i in 1:len) { c_array[,,i] <- a_array[,,i] %*% b_array[,,i] }
return(c_array)
}
array_combine(atest,atest)
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
# Simulate a Gaussian LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK  and concurrent filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
delta.noise <- iden
delta.signal <- delta
spec.noise <- f.irr
spec.signal <- f.mu
array_combine <- function(a_array,b_array,inv=FALSE)
{
N <- dim(a_array)[1]
len <- dim(a_array)[3]
c_array <- array(0,c(N,N,len))
if(inv)
{
for(i in 1:len) { c_array[,,i] <- a_array[,,i] %*% solve(b_array[,,i]) }
} else
{
for(i in 1:len) { c_array[,,i] <- a_array[,,i] %*% b_array[,,i] }
}
return(c_array)
}
d.noise <- dim(delta.noise)[3] - 1
d.signal <- dim(delta.signal)[3] - 1
N <- dim(spec.noise)[1]
grid <- dim(spec.noise)[3]
m <- floor(grid/2)
lambda <- 2*pi*(seq(1,grid) - (m+1))/grid
delta.process <- polymulMat(delta.noise,delta.signal)
d.process <- dim(delta.process)[3] - 1
frf.noise <- t(rep(1,grid)) %x% delta.noise[,,1]
if(d.noise > 0) {
for(i in 1:d.noise)
{
frf.noise <- frf.noise + t(exp(-1i*lambda*i)) %x% delta.noise[,,i+1]
} }
frf.noise <- array(frf.noise,c(N,N,grid))
frf.signal <- t(rep(1,grid)) %x% delta.signal[,,1]
if(d.signal > 0) {
for(i in 1:d.signal)
{
frf.signal <- frf.signal + t(exp(-1i*lambda*i)) %x% delta.signal[,,i+1]
} }
frf.signal <- array(frf.signal,c(N,N,grid))
frf.process <- array_combine(frf.noise,frf.signal,FALSE)
frf.process[,,1]
frf.process[,,2]
dim(frf.process)
lambda[2500]
frf.process[,,2500]
frf.process[,,2501]
plot.ts(frf.process[1,1,])
spec.signal.del <- array(t(rep(1,grid)) %x% diag(N),c(N,N,grid))
spec.noise.del <- array(t(rep(1,grid)) %x% diag(N),c(N,N,grid))
spec.data.del <- array(t(rep(1,grid)) %x% diag(N),c(N,N,grid))
frf.wk <- array(t(rep(1,grid)) %x% diag(N),c(N,N,grid))
for(k in 1:grid)
{
spec.noise.del[,,k] <- frf.signal[,,k] %*% spec.noise[,,k] %*% Conj(t(frf.signal[,,k]))
spec.signal.del[,,k] <- frf.noise[,,k] %*% spec.signal[,,k] %*% Conj(t(frf.noise[,,k]))
spec.data.del[,,k] <- spec.noise.del[,,k] + spec.signal.del[,,k]
frf.wk[,,k] <- spec.signal.del[,,k] %*% solve(spec.data.del[,,k])
}
filter.wk <- mdfa.coeff(frf.wk,len,len)
acf.data.del <- mdfa.coeff(spec.data.del,0,len)
data.sf <- mvar.specfact(aperm(acf.data.del,c(1,3,2)))
dim(acf.data.del)
acf.data.del[,,1]
acf.data.del[,,1001]
plot.ts(spec.data.del[1,1,])
data.sf <- mvar.specfact(aperm(acf.data.del,c(1,3,2)))
temp <- aperm(acf.data.del,c(1,3,2))
dim(temp)
x.acf <- temp
N <- dim(x.acf)[1]
q <- dim(x.acf)[2] - 1
Zzero <- matrix(0,nrow=N,ncol=N)
eps <- 1
thresh <- 10^(-15)
Linvt <- diag(N)
Dinv <- solve(x.acf[,1,])
sqrtLam <- svd(x.acf[,1,])
sqrtLam <- sqrtLam$u %*% diag(sqrt(sqrtLam$d),nrow=N) %*% t(sqrtLam$u)
Gseq <- solve(sqrtLam)
oldLam <- x.acf[,1,]
Dsqrt <- sqrtLam
gamSeq <- NULL
count <- 1
maxcount <- 500
while((eps > thresh)&&(count<maxcount))
{
if(count <= q) nextgam <- x.acf[,count+1,] else nextgam <- Zzero
gamSeq <- cbind(nextgam,gamSeq)
Bseq <- gamSeq %*% Gseq
Lam <- x.acf[,1,] - Bseq %*% t(Bseq)
sqrtLam <- svd(Lam)
sqrtLam <- sqrtLam$u %*% diag(sqrt(sqrtLam$d),nrow=N) %*% t(sqrtLam$u)
Gseq <- rbind(cbind(Gseq,-1*Gseq%*%t(Bseq)%*%solve(sqrtLam)),
cbind(t(rep(1,count) %x% Zzero),solve(sqrtLam)))
count <- count+1
if(count > q) eps <- sum((oldLam - Lam)^2)
oldLam <- Lam
#		print(c(count,eps))
#		print(Lam)
}
Thetas <- cbind(Bseq,sqrtLam) %*% (diag(count) %x% solve(sqrtLam))
arrayThetas <- array(Thetas,dim=c(N,N,count))
out <- list(arrayThetas[,,(count-q):count],Lam,count)
count
q
trunc <- 500
acf.data.del <- mdfa.coeff(spec.data.del,0,trunc)
data.sf <- mvar.specfact(aperm(acf.data.del,c(1,3,2)))
data.theta <- data.sf[[1]][,,seq(len+1,1),drop=FALSE]
data.theta <- data.sf[[1]][,,seq(trunc+1,1),drop=FALSE]
dim(data.sf[[1]])
data.theta <- data.sf[[1]][,,seq(trunc,1),drop=FALSE]
data.sigma <- data.sf[[2]]
data.theta[,,1]
data.theta[,,2]
data.sf[[2]]
frf.theta <- t(rep(1,grid)) %x% data.theta[,,1]
for(i in 1:len)
{
frf.theta <- frf.theta + t(exp(-1i*lambda*i)) %x% data.theta[,,i+1]
}
for(i in 1:(trunc-1))
{
frf.theta <- frf.theta + t(exp(-1i*lambda*i)) %x% data.theta[,,i+1]
}
frf.theta <- t(rep(1,grid)) %x% data.theta[,,1]
for(i in 1:(trunc-1))
{
frf.theta <- frf.theta + t(exp(-1i*lambda*i)) %x% data.theta[,,i+1]
}
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(phi_partial,frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- t(rep(1,grid)) %x% diag(N) - causal_frf
causal_frf <- array_combine(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + causal_frf
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
i
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(phi_partial,frf.theta,TRUE)
dim(frf.theta)
dim(phi_partial)
dim(frf.process)
frf.theta <- array(frf.theta,c(N,N,grid))
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- t(rep(1,grid)) %x% diag(N) - causal_frf
causal_frf <- array_combine(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + causal_frf
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
dim(causal_frf)
causal_frf[,,1]
temp <- matrix(causal_frf,nrow=N)
dim(temp)
temp[,1:2]
temp[,3:4]
causal_frf[,,2]
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
causal_frf <- array_combine(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + causal_frf
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
i
dim(filter.wk)
len
filter.wk <- mdfa.coeff(frf.wk,len,len)
filter.wk <- mdfa.coeff(frf.wk,-len,len)
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
causal_frf <- array_combine(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + causal_frf
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
i
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
causal_frf <- array_combine(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],causal_frf)
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
dim(causal_frf)
filter.wk[,,len+1-i]
causal_frf <- array_combine(array(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],
c(N,N,grid)),causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + causal_frf
frf.wh <- frf.wh + matrix(causal_frf,nrow=N)
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1])
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
causal_frf <- array_combine(array(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],
c(N,N,grid)),causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + matrix(causal_frf,nrow=N)
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
i
data.theta[,,500]
frf.wh <- t(rep(1,grid)) %x% filter.wk[,,len+1]
phi <- array(0,c(N,N,len+1))
phi[,,1] <- data.theta[,,1] %*% solve(delta.process[,,1])
phi_partial <- t(rep(1,grid)) %x% phi[,,1]
for(i in 1:len)
{
if(i < trunc) { phi[,,i+1] <- data.theta[,,i+1] %*% solve(delta.process[,,1]) }
for(j in 1:min(i,d.process))
{
phi[,,i+1] <- phi[,,i+1] - phi[,,i-j+1] %*%
delta.process[,,j+1] %*% solve(delta.process[,,1])
}
causal_frf <- array_combine(array(phi_partial,c(N,N,grid)),frf.theta,TRUE)
causal_frf <- array_combine(causal_frf,frf.process,FALSE)
causal_frf <- array(t(rep(1,grid)) %x% diag(N) - matrix(causal_frf,nrow=N),c(N,N,grid))
causal_frf <- array_combine(array(t(exp(1i*lambda*i)) %x% filter.wk[,,len+1-i],
c(N,N,grid)),causal_frf)
frf.wh <- frf.wh + t(exp(-1i*lambda*i)) %x% filter.wk[,,len+1+i]
frf.wh <- frf.wh + matrix(causal_frf,nrow=N)
phi_partial <- phi_partial + t(exp(-1i*lambda*i)) %x% phi[,,i+1]
}
frf.wh <- array(frf.wh,c(N,N,grid))
dim(frf.wh)
plot.ts(frf.wh[1,1,])
plot.ts(frf.wh[1,2,])
plot.ts(frf.wh[2,1,])
plot.ts(frf.wh[2,2,])
plot.ts(Re(frf.wh[1,1,]))
plot.ts(Im(frf.wh[1,1,]))
test <- mdfa.coeff(frf.wh,-len,len)
test[,,1]
plot.ts(test[1,1,])
plot.ts(test[1,1,900:1100])
plot.ts(test[2,2,900:1100])
plot.ts(test[2,1,900:1100])
plot.ts(test[1,2,900:1100])
test[,,1000]
test[,,1001]
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
trend.whfilter <- mdfa.coeff(trend.whfrf,-len,len)
plot.ts(trend.whfilter[1,1,])
plot.ts(trend.whfilter[1,2,])
plot.ts(trend.whfilter[2,2,])
