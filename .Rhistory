toc()
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var.pre2par(z,p,N)
toc()
phi <- var.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var.pre2par(z,p,N)
toc()
phi <- var.par2pre(param)
toc()
psi <- z
var.order <- p
sqrtm <- function(A) {return(t(chol(A))) }
psi.mat <- matrix(psi,nrow=N,ncol=N*var.order)
psi.array <- array(psi.mat,c(N,N,var.order))
pacf.array <- array(0,c(N,N,var.order))
for(k in 1:var.order)
{
pacf.array[,,k] <- solve(sqrtm(diag(N) + psi.array[,,k] %*%
t(psi.array[,,k]))) %*% psi.array[,,k]
}
sqrt.array <- array(0,c(N,N,var.order+1))
sqrt.array[,,var.order+1] <- diag(N)
for(k in var.order:1)
{
S.mat <- sqrtm(sqrt.array[,,k+1]) %*%
solve(sqrtm(diag(N)-pacf.array[,,k] %*% t(pacf.array[,,k])))
sqrt.array[,,k] <- S.mat %*% t(S.mat)
}
Sigma <- sqrt.array[,,1]
sigma.array <- array(0,c(N,N,var.order+1))
sigmastar.array <- array(0,c(N,N,var.order+1))
sigma.array[,,1] <- Sigma
sigmastar.array[,,1] <- Sigma
phi.array <- list()
phistar.array <- list()
Sstar.mat <- S.mat
for(k in 1:var.order)
{
phi.array[[k]] <- array(0,c(N,N,k))
phistar.array[[k]] <- array(0,c(N,N,k))
phi.array[[k]][,,k] <- S.mat %*% pacf.array[,,k] %*% solve(Sstar.mat)
phistar.array[[k]][,,k] <- Sstar.mat %*% t(pacf.array[,,k]) %*% solve(S.mat)
if(k > 1)
{
for(j in 1:(k-1))
{
phi.array[[k]][,,j] <- phi.array[[k-1]][,,j] - phi.array[[k]][,,k] %*% phistar.array[[k-1]][,,k-j]
phistar.array[[k]][,,j] <- phistar.array[[k-1]][,,j] - phistar.array[[k]][,,k] %*% phi.array[[k-1]][,,k-j]
}
}
sigma.array[,,k+1] <- sigma.array[,,k] - phi.array[[k]][,,k] %*% sigmastar.array[,,k] %*% t(phi.array[[k]][,,k])
sigmastar.array[,,k+1] <- sigmastar.array[,,k] - phistar.array[[k]][,,k] %*% sigma.array[,,k] %*% t(phistar.array[[k]][,,k])
S.mat <- sqrtm(sigma.array[,,k+1])
Sstar.mat <- sqrtm(sigmastar.array[,,k+1])
}
k
sigma.array[,,k+1]
eigen(sigma.array[,,k+1])$values
chol(sigma.array[,,k+1])
sigmastar.array[,,k+1]
msqrt
var2.par2pre <- function(param)
{
##########################################################################
#
#	var2.par2pre.r
# 	    Copyright (C) 2020  Tucker McElroy
#       (Original code by Anindya Roy, adapted by Tucker McElroy)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
############################################################################
################# Documentation #####################################
#
#	Purpose: generates a stable dimension N VAR(p) process
#	Background:
#		param is the name for the model parameters entered into
#		an array object with a more intuitive structure, whereas
#		psi refers to a vector of real numbers containing all
#		hyper-parameters (i.e., reals mapped bijectively to the parameter	manifold)
#		Algorithm is that of Roy, McElroy, and Linton (2019)
#	Notes: only for use with N > 1 and p > 0
#	Inputs:
#		param: N x N x p array,
#		  where p is the VAR order and N is the dimension of the process
#	Outputs:
#		psi: vector of real numbers, of length p*N^2
# Requires: VARMAauto.r
#   (the msqrt function is borrowed from MTS package, but this need not be loaded)
#
####################################################################
msqrt <- function (M)
{
if (!is.matrix(M))
M = as.matrix(M)
n1 = nrow(M)
if (n1 == 1) {
Mh = sqrt(M)
Mhinv = 1/Mh
}
if (n1 > 1) {
M = (M + t(M))/2
m1 = eigen(M)
V = m1$vectors
eiv = sqrt(m1$values)
L = diag(eiv)
Linv = diag(1/eiv)
Mh = V %*% L %*% t(V)
Mhinv = V %*% Linv %*% t(V)
}
msqrt <- list(mtxsqrt = Mh, invsqrt = Mhinv)
}
N <- dim(param)[1]
p <- dim(param)[3]
u <- VARMAauto(param,NULL,diag(N),p)
A <- array(0, dim = c(N,N,p))
dd <- u[,,1]
ddinv <- solve(dd)
A[,,1] <- u[,,2] %*% msqrt(dd)$invsqrt
T1 <- 0*A[,,1]
txi <- tkappa <- T2 <- ddinv <- NULL
if (p > 1){
for(j in 2:p){
if(j == 2){uinv <- solve(u[,,1]) }
else{uinv <- rbind(cbind((uinv + T2%*%t(T1)), -T2), cbind(-t(T2),ddinv))  }
tkappa <- cbind(t(u[,,j]),tkappa)
txi <- cbind(txi, u[,,j])
T1 <- uinv %*% t(tkappa)
dd <- u[,,1] - tkappa %*% T1
ddinv <- solve(dd)
T2 <- T1 %*% ddinv
A[,,j] <- (u[,,(j+1)] - txi %*% uinv %*% t(tkappa)) %*% msqrt(dd)$invsqrt
}
}
pre <- c(A)
return(pre)
}
var2.pre2par <- function(psi,p,N)
{
##########################################################################
#
#	var2.pre2par.r
# 	    Copyright (C) 2020  Tucker McElroy
#       (Original code by Anindya Roy, adapted by Tucker McElroy)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
############################################################################
################# Documentation #####################################
#
#	Purpose: generates a stable dimension N VAR(p) process
#	Background:
#		param is the name for the model parameters entered into
#		an array object with a more intuitive structure, whereas
#		psi refers to a vector of real numbers containing all
#		hyper-parameters (i.e., reals mapped bijectively to the parameter	manifold)
#		Algorithm is that of Ansley and Kohn (1986)
#	Notes: only for use with N > 1 and p > 0
#	Inputs:
#		psi: vector of real numbers, of length p*N^2
#		p: the VAR order p
#		N: dimension of the process
#		debug: a Boolean flag; if true, outputs stability check
#	Outputs:
#		param: N x N x p array
# Requires: VARMAauto.r
#   (the msqrt function is borrowed from MTS package, but this need not be loaded)
#
####################################################################
msqrt <- function (M)
{
if (!is.matrix(M))
M = as.matrix(M)
n1 = nrow(M)
if (n1 == 1) {
Mh = sqrt(M)
Mhinv = 1/Mh
}
if (n1 > 1) {
M = (M + t(M))/2
m1 = eigen(M)
V = m1$vectors
eiv = sqrt(m1$values)
L = diag(eiv)
Linv = diag(1/eiv)
Mh = V %*% L %*% t(V)
Mhinv = V %*% Linv %*% t(V)
}
msqrt <- list(mtxsqrt = Mh, invsqrt = Mhinv)
}
prephi <- psi[1:(p*N*N)]
A <- array(prephi, dim = c(N,N,p))
param <- array(0,dim = c(N,N,p))
u <- array(0,dim=c(N,N,(p+1)))
u[,,1] <- diag(N) + matrix(A,N,N*p) %*% t(matrix(A,N,N*p))
dd <- u[,,1]
uinv <- solve(u[,,1])
u[,,2] <- A[,,1] %*% msqrt(dd)$mtxsqrt
txi <- u[,,2]
tkappa <- t(txi)
if (p > 1){
for(j in 3:(p+1)){
T1 <- uinv %*% t(tkappa)
dd <- u[,,1] - tkappa %*% T1
dd2 <- msqrt(dd)$mtxsqrt
u[,,j] <-  txi %*% T1 + A[,,(j-1)] %*% dd2
ddinv <- solve(dd)
T2 <- T1 %*% ddinv
uinv <- rbind(cbind((uinv + T2 %*% t(T1)), -T2), cbind(-t(T2),ddinv))
tkappa <- cbind(t(u[,,j]),tkappa)
txi <- cbind(txi, u[,,j])
}
}
phi1 <- txi %*% uinv
for(j in 1:p){
param[,,j] <- phi1[,(N*(j-1)+1):(N*j)]
}
return(param)
}
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var.pre2par(z,p,N)
toc()
phi <- var.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
p <- 10
N <- 7
z <- rnorm(N*N*p)
tic("pre2par")
tic("par2pre")
param <- var2.pre2par(z,p,N)
toc()
phi <- var2.par2pre(param)
toc()
8537/168916
8537/150000
8537/137700
168916/26
.15*168916/26
.05*168916/26
.2*168916/26
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
getwd()
setwd("C:\\Users\\neide\\Documents\\GitHub\\MDFA-Legacy")
# set directory to GitHub/MDFA-Legacy
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
getwd()
# visualize
load("~\\Sweave\\Data\\petrol.RData")
# visualize
load("~\\Sweave\\Data\\petrol.RData")
load("~\\Sweave\\Data\\petrol.RData")
load("\\Sweave\\Data\\petrol.RData")
getwd()
load("/Sweave/Data/petrol.RData")
load("/Sweave/Data/petrol.RData")
load("/Sweave/Data/petrol.RData")
getwd()
load("Sweave/Data/petrol.RData")
petrol
petrol <- ts(petrol[,c(1,2)],start=c(1973,1),frequency=12,
names=c("Consumption","Imports"))
plot(petrol)
plot(petrol,xlab="Year")
file <- paste("petrol_data.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special",
width = 6, height = 4)
invisible(dev.off())
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
invisible(dev.off())
file <- paste("petrol_data.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special",
width = 6, height = 4)
plot(petrol,xlab="Year")
invisible(dev.off())
# Simulate a Gaussian LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
plot(x.sim)
plot(ts(x.sim))
Sigma.mu
sigma.irr
Sigma.irr
grid <- 1000
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.frf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
dim(trend.frf)
mdfa.coef
# construct and apply MB WK filter
grid <- 1000
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,len,len)
dim(trend.wkfilter)
len
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
dim(trend.wkfilter)
plot(ts(trend.wkfilter[1,1,]))
# construct and apply MB WK filter
grid <- 7000
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
plot(ts(trend.wkfilter[1,1,]))
plot(ts(trend.wkfilter[2,2,]))
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
plot(ts(x.trend.ideal))
plot.ts(x.sim[,1])
lines(ts(c(rep(NA,len),x.trend.ideal[,1],rep(NA,len)),col=2)
lines(ts(c(rep(NA,len),x.trend.ideal[,1],rep(NA,len))),col=2)
# construct and apply MB WK filter
grid <- T.sim
# get MDFA concurrent filter
q <- 30
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
dim(trend.wkfrf)
# construct and apply MB WK filter
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
constraints.mdfa <- mdfa.getconstraints(trend.wkfrf,0,NULL,0*diag(N),q)
dim(constraints.mdfa[[1]])
dim(constraints.mdfa[[2]])
bw.mdfa <- mdfa.filter(trend.wkfrf,spec.hat,constraints.mdfa[[1]],constraints.mdfa[[2]])
x.trend.mdfa <- mvar.filter(x.sim,bw.mdfa[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(bw.mdfa[[2]])
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
trend.whfrf <- mdfa.whfrf(iden,delta,f.irr,f.mu,len)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
