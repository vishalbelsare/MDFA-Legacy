rbind(iris.setosa[1:2,],iris.versi[1:2,],iris.virgi[1:2,])
d_setosa_vec
iris.test
iris.test$Species == iris.test$prediction
(iris.test$Species == "setosa") & (iris.test$prediction = "setosa")
iris.test$Species == "setosa"
(iris.test$Species == "setosa") && (iris.test$prediction = "setosa")
intersect(iris.test$Species == "setosa",iris.test$prediction = "setosa")
intersect(iris.test$Species == "setosa",iris.test$prediction == "setosa")
(iris.test$Species == "setosa") & (iris.test$prediction == "setosa")
sum((iris.test$Species == "setosa") & (iris.test$prediction == "setosa"))
setosa_true <- sum((iris.test$Species == "setosa") & (iris.test$prediction == "setosa"))
versicolor_true <- sum((iris.test$Species == "versicolor") & (iris.test$prediction == "versicolor"))
virginica_true <- sum((iris.test$Species == "virginica") & (iris.test$prediction == "virginica"))
class_tab <- c(n_setosa,n_versicolor,n_virginica)
class_tab <- rbind(class_tab,
c(setosa_true,versicolor_true,virginica_true))
class_tab <- rbind(class_tab,class_tab[1,] - class_tab[2,])
class_tab
iris.test$Species == "versicolor"
iris.test$Species == "versicolor"
(iris.test$Species == "versicolor") & (iris.test$prediction == "versicolor")
iris.test
prediction <- c()
d_setosa_vec <- c()
d_versicolor_vec <- c()
d_virginica_vec <- c()
label <- c("setosa", "versicolor", "virginica")
for(i in 1:nrow(iris.test)){
#Read an ovservation in test data
x <- t(iris.test[i,1:4])
#Calculate linear discriminant functions for each
d_setosa <- alpha_setosa + t(beta_setosa) %*% x
d_versicolor <- alpha_versicolor + t(beta_versicolor) %*% x
d_virginica <- alpha_virginica + t(beta_virginica) %*% x
#Classify the observation to the class with highest function value
d_vec <- c(d_setosa, d_versicolor, d_virginica)
prediction <- append(prediction, label[which.max( d_vec )])
d_setosa_vec <- append(d_setosa_vec, d_setosa)
d_versicolor_vec <- append(d_versicolor_vec, d_versicolor)
d_virginica_vec <- append(d_virginica_vec, d_virginica)
}
#Combine the predicted results to the test dataset.
iris.test$prediction <- prediction
#3D scatter plot
library("scatterplot3d")
col_vec <- c(rep("red", 10), rep("blue", 10), rep("black", 10))
pch_vec <- c(rep(15, 10), rep(17, 10), rep(19, 10))
scatterplot3d(x = d_setosa_vec, y = d_versicolor_vec, z = d_virginica_vec,
xlab = "d_setosa", ylab = "d_versicolor",	zlab="d_virginica",
color="red", pch=19, angle = 55 , cex.symbols=2, cex.lab=2)
scatterplot3d(x = d_setosa_vec, y = d_versicolor_vec, z = d_virginica_vec,
xlab = "d_setosa", ylab = "d_versicolor",	zlab="d_virginica",
color=col_vec, pch=pch_vec, angle = 55 , cex.symbols=2, cex.lab=2)
iris.test
setosa_true <- sum((iris.test$Species == "setosa") & (iris.test$prediction == "setosa"))
versicolor_true <- sum((iris.test$Species == "versicolor") & (iris.test$prediction == "versicolor"))
virginica_true <- sum((iris.test$Species == "virginica") & (iris.test$prediction == "virginica"))
class_tab <- c(n_setosa,n_versicolor,n_virginica)
class_tab <- rbind(class_tab,
c(setosa_true,versicolor_true,virginica_true))
class_tab <- rbind(class_tab,class_tab[1,] - class_tab[2,])
class_tab
setosa_true <- sum((iris.test$Species == "setosa") & (iris.test$prediction == "setosa"))
versicolor_true <- sum((iris.test$Species == "versicolor") & (iris.test$prediction == "versicolor"))
virginica_true <- sum((iris.test$Species == "virginica") & (iris.test$prediction == "virginica"))
class_tab <- c(n_setosa,n_versicolor,n_virginica)
class_tab <- rbind(class_tab,
c(setosa_true,versicolor_true,virginica_true))
class_tab <- rbind(class_tab,class_tab[1,] - class_tab[2,])
colnames(class_tab) <- c("setosa","versicolor","virginica")
rownames(calss_tab) <- c("Number Observations","Number Correct","Number Wrong")
setosa_true <- sum((iris.test$Species == "setosa") & (iris.test$prediction == "setosa"))
versicolor_true <- sum((iris.test$Species == "versicolor") & (iris.test$prediction == "versicolor"))
virginica_true <- sum((iris.test$Species == "virginica") & (iris.test$prediction == "virginica"))
class_tab <- c(n_setosa,n_versicolor,n_virginica)
class_tab <- rbind(class_tab,
c(setosa_true,versicolor_true,virginica_true))
class_tab <- rbind(class_tab,class_tab[1,] - class_tab[2,])
colnames(class_tab) <- c("setosa","versicolor","virginica")
rownames(class_tab) <- c("Number Observations","Number Correct","Number Wrong")
class_tab
knitr::opts_knit$set(root.dir = 'C:/Users/neide/Documents/GitHub/ma189/Data')
install.packages("ISLR")
knitr::opts_knit$set(root.dir = 'C:/Users/neide/Documents/GitHub/ma189/Data')
library(ISLR)
data(Default)
y <- as.numeric(Default$default=="Yes")
## Use the credit card balance to predict default probability
balance.fit = glm(y~balance, data=Default ,family=binomial)
summary(balance.fit)
pred_balance <- function(obs_balance){
x <- c(1,obs_balance)
pred <- as.numeric(as.numeric(x %*% balance.fit$coefficients))
pred <- 1/(1+exp(-pred))
return(pred)
}
pred1 <- pred_balance(1000)
pred2 <- pred_balance(2000)
head(Default)
dim(Default)
Default_good <- Default[Default$default == "No",]
Default_bad <- Default[Default$default == "Yes",]
plot(x = Default_good$balance, y = Default_good$income)
plot(x = Default_good$balance, y = Default_good$income)
library(ISLR)
data(Default)
Default_good <- Default[Default$default == "No",]
Default_bad <- Default[Default$default == "Yes",]
plot(x = Default_good$balance, y = Default_good$income,col=3)
points(x = Default_bad$balance, y = Default_bad$income,col=2)
library(ISLR)
data(Default)
Default_good <- Default[Default$default == "No",]
Default_bad <- Default[Default$default == "Yes",]
plot(x = Default_good$balance, y = Default_good$income,col=3,
xlab = "Balance",ylab = "Income")
points(x = Default_bad$balance, y = Default_bad$income,col=2)
boxplot(Balance ~ default, data=Default)
boxplot(balance ~ default, data=Default)
boxplot(balance ~ default, data=Default, col=c(3,2))
boxplot(balance ~ default, data=Default, col=c(3,2))
boxplot(income ~ default, data=Default, col=c(3,2))
help(boxplot)
y <- as.numeric(Default$default=="Yes")
## Use the credit card balance to predict default probability
balance.fit <- glm(y~balance, data=Default,family=binomial)
summary(balance.fit)
stu <- as.numeric(Default$student=="Yes")
student.fit <- glm(y~stu,data=Default,family=binomial)
summary(student.fit)
p1 <- student.fit$fitted.values[2]
p0 <- student.fit$fitted.values[1]
stu <- as.numeric(Default$student=="Yes")
student.fit <- glm(y~stu,data=Default,family=binomial)
summary(student.fit)
student.fit$fitted.values
pred_student <- function(obs_student){
x <- c(1,obs_student)
pred <- as.numeric(as.numeric(x %*% student.fit$coefficients))
pred <- 1/(1+exp(-pred))
return(pred)
}
x <- seq(-10,10,.1)
x <- seq(-10,10,.1)
y <- (1+exp(-x))^{-1}
plot(ts(y),xlab="x",ylab="")
library(ISLR)
data(Default)
y <- as.numeric(Default$default=="Yes")
stu <- as.numeric(Default$student=="Yes")
income <- 0.001*Default$income
balance <- Default$balance
all.fit <- glm(y~stu+balance+income,data=Default,family=binomial)
summary(all.fit)
all.fit$coefficients
obs <- c(1,1500,40)
x <- c(1,obs)
pred <- as.numeric(as.numeric(x %*% all.fit$coefficients))
pred <- 1/(1+exp(-pred))
pred
pred <- as.numeric(as.numeric(x %*% all.fit$coefficients))
pred
all.fit$coefficients
x
1/(1+exp(pred))
1/(1+exp(-pred))
fitted.prob <- as.numeric(all.fit$fitted.values)
prob.stu <- fitted.prob[stu==1]
balance.stu <- balance[stu==1]
M1 <- matrix(c(prob.stu,balance.stu), ncol = 2)
M1 <- M1[order(M1[,1], decreasing = FALSE),]
plot(M1[,2], M1[,1],type='l',lwd=2,col="orange")
prob.nonstu <- fitted.prob[stu==0]
balance.nonstu <- balance[stu==0]
M2 <- matrix(c(prob.nonstu,balance.nonstu), ncol = 2)
M2 <- M2[order(M2[,1], decreasing = FALSE),]
lines(M2[,2],M2[,1],lwd=2,col="slateblue1")
stu.rate <- sum(stu[y==1])/sum(stu)
nonstu.rate <- sum((1-stu)[y==1])/sum(1-stu)
fitted.prob <- as.numeric(all.fit$fitted.values)
prob.stu <- fitted.prob[stu==1]
balance.stu <- balance[stu==1]
M1 <- matrix(c(prob.stu,balance.stu), ncol = 2)
M1 <- M1[order(M1[,1], decreasing = FALSE),]
plot(M1[,2], M1[,1],type='l',lwd=2,col="orange")
prob.nonstu <- fitted.prob[stu==0]
balance.nonstu <- balance[stu==0]
M2 <- matrix(c(prob.nonstu,balance.nonstu), ncol = 2)
M2 <- M2[order(M2[,1], decreasing = FALSE),]
lines(M2[,2],M2[,1],lwd=2,col="slateblue1")
stu.rate <- sum(stu[y==1])/sum(stu)
nonstu.rate <- sum((1-stu)[y==1])/sum(1-stu)
abline(h=stu.rate,lwd=2,lty=2,col="orange")
abline(h=nonstu.rate,lwd=2,lty=2,col="slateblue1")
fitted.prob <- as.numeric(all.fit$fitted.values)
prob.stu <- fitted.prob[stu==1]
balance.stu <- balance[stu==1]
M1 <- matrix(c(prob.stu,balance.stu), ncol = 2)
M1 <- M1[order(M1[,1], decreasing = FALSE),]
plot(M1[,2], M1[,1],type='l',lwd=2,col="orange",
xlab="Credit Card Balance",ylab="Default Rate")
prob.nonstu <- fitted.prob[stu==0]
balance.nonstu <- balance[stu==0]
M2 <- matrix(c(prob.nonstu,balance.nonstu), ncol = 2)
M2 <- M2[order(M2[,1], decreasing = FALSE),]
lines(M2[,2],M2[,1],lwd=2,col="slateblue1")
stu.rate <- sum(stu[y==1])/sum(stu)
nonstu.rate <- sum((1-stu)[y==1])/sum(1-stu)
abline(h=stu.rate,lwd=2,lty=2,col="orange")
abline(h=nonstu.rate,lwd=2,lty=2,col="slateblue1")
stu
cor(stu,balance)   # Pearson's sample correlation
cor.test(stu,balance, method="spearman")  # Spearman's rank correlation
boxplot(balance~Default$student,xlab="Student Status",
ylab="Credit Card Balance",col=c("slateblue1","orange"))
x1 <- seq(-1.5,1.5,.01)
x2 <- seq(-1.5,1.5,.01)
y <- -1 + (-2/3)*x1
plot(x1,y)
x1 <- seq(-1.5,1.5,.01)
x2 <- seq(-1.5,1.5,.01)
y <- -1 + (-2/3)*x1
plot(x1,y,type="l")
x1 <- seq(-1.5,1.5,.01)
x2 <- seq(-1.5,1.5,.01)
y <- -1 + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
x1 <- seq(-1.5,1.5,.01)
x2 <- seq(-1.5,1.5,.01)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
x1 <- seq(-1.5,1.5,.01)
x2 <- seq(-1.5,1.5,.01)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
points(x1,x2)
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=2)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=3)}
}
}
help(points)
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=5,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=7,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=8,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=6,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5),lwd=2)
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=6,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
x1 <- seq(-1.5,1.5,.1)
x2 <- seq(-1.5,1.5,.1)
y <- -(1/3) + (-2/3)*x1
plot(x1,y,type="l",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5),lwd=3)
for(i in 1:length(x1))
{
for(j in 1:length(x2))
{
if(1+2*x1[i]+3*x2[j] < 0) { points(x1[i],x2[j],col=6,pch=16)}
if(1+2*x1[i]+3*x2[j] > 0) { points(x1[i],x2[j],col=4,pch=16)}
}
}
# try different choices of n: 1, 9, 25, 100
n <- 1
lambda <- 2
xbars <- NULL
for(i in 1:1000) {
x <- rexp(n, rate = lambda)
xbar <- mean(x)
xbars <- c(xbars,xbar) }
mean(xbars)
sd(xbars)
hist(xbars)
# try different choices of n: 1, 9, 25, 100
n <- 9
lambda <- 2
xbars <- NULL
for(i in 1:1000) {
x <- rexp(n, rate = lambda)
xbar <- mean(x)
xbars <- c(xbars,xbar) }
mean(xbars)
sd(xbars)
hist(xbars)
# try different choices of n: 1, 9, 25, 100
n <- 25
lambda <- 2
xbars <- NULL
for(i in 1:1000) {
x <- rexp(n, rate = lambda)
xbar <- mean(x)
xbars <- c(xbars,xbar) }
mean(xbars)
sd(xbars)
hist(xbars)
# try different choices of n: 1, 9, 25, 100
n <- 100
lambda <- 2
xbars <- NULL
for(i in 1:1000) {
x <- rexp(n, rate = lambda)
xbar <- mean(x)
xbars <- c(xbars,xbar) }
mean(xbars)
sd(xbars)
hist(xbars)
runif_circle <- function(radius)
{
bad <- TRUE
while(bad)
{
x <- runif(1,min=-radius,max=radius)
y <- runif(1,min=-radius,max=radius)
z <- sqrt(x^2 + y^2)
if(z <= radius) { bad <- FALSE }
}
return(c(x,y))
}
runifs_circle <- function(n,radius)
{
z <- NULL
for(i in 1:n)
{
z <- rbind(z,runif_circle(radius))
}
return(z)
}
# try different choices of n: 1, 9, 25, 100
n <- 25
xbars <- NULL
for(i in 1:1000) {
X <- runifs_circle(n,1)
xbar <- colMeans(X)
xbars <- rbind(xbars,xbar) }
colMeans(xbars)
var(xbars)
hist(xbars[,1])
hist(xbars[,2])
n <- 9
mu <- 2
sigma <- 3
students <- NULL
x <- rnorm(n, mean = mu, sd = sigma)
student <- (mean(x) - mu)/(sd(x)/sqrt(n))
alpha <- .05
c(abs(student),qt(1-alpha/2,df=n-1))
n <- 9
mu <- 2
sigma <- 3
students <- NULL
x <- rnorm(n, mean = mu, sd = sigma)
student <- (mean(x) - mu)/(sd(x)/sqrt(n))
alpha <- .05
c(abs(student),qt(1-alpha/2,df=n-1))
n <- 9
mu <- 2
sigma <- 3
students <- NULL
x <- rnorm(n, mean = mu, sd = sigma)
student <- (mean(x) - mu)/(sd(x)/sqrt(n))
alpha <- .05
c(abs(student),qt(1-alpha/2,df=n-1))
n <- 9
mu <- 2
sigma <- 3
students <- NULL
x <- rnorm(n, mean = mu, sd = sigma)
student <- (mean(x) - mu)/(sd(x)/sqrt(n))
alpha <- .05
c(abs(student),qt(1-alpha/2,df=n-1))
n <- 9
mu <- 2
sigma <- 3
students <- NULL
x <- rnorm(n, mean = mu, sd = sigma)
student <- (mean(x) - mu)/(sd(x)/sqrt(n))
alpha <- .05
c(abs(student),qt(1-alpha/2,df=n-1))
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
path.main
# set directory to GitHub/MDFA-Legacy
setwd("C:/Users/neide/Documents/GitHub/MDFA-Legacy")
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
# Simulate a Gaussian LLM  of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
len <- 1000
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),T.sim+burn,Inf)
Sigma.mu <- mu.sim[[2]]
mu.sim <- mdfa.ucsim(delta,mu.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),T.sim,Inf)
Sigma.irr <- irr.sim[[2]]
irr.sim <- irr.sim[[1]]
x.sim <- mu.sim + irr.sim
# construct and apply MB WK  and concurrent filters
grid <- T.sim - d
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.wkfrf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
trend.wkfilter <- mdfa.coeff(trend.wkfrf,-len,len)
x.trend.ideal <- mvar.filter(x.sim,trend.wkfilter)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
