axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(x.trend.mdfa[,2],col=grey(.7))
plot(ts(x.trend.ideal[,3]),ylab="",xlab="",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(x.trend.mdfa[,3],col=grey(.7))
mtext("Time", side = 1, line = 1,outer=TRUE)
invisible(dev.off())
par(oma=c(2,0,0,0),mar=c(2,4,2,2)+0.1,mfrow=c(3,1),cex.lab=.8)
plot(ts(gain.psi,start=-1,frequency=m),col=1,ylim=c(0,1),main="Gain",
ylab="",xlab="",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(ts(lp.gain1,start=-1,frequency=m),col="orange")
lines(ts(lp.gain2,start=-1,frequency=m),col="green")
lines(ts(lp.gain3,start=-1,frequency=m),col="violet")
plot(ts(phased.psi,start=-1,frequency=m),col=1,
ylim=c(0,max(na.exclude(lp.phased1),na.exclude(lp.phased2),
na.exclude(lp.phased3))),main="Phase Delay",
ylab="",xlab="",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(ts(lp.phased1,start=-1,frequency=m),col="orange")
lines(ts(lp.phased2,start=-1,frequency=m),col="green")
lines(ts(lp.phased3,start=-1,frequency=m),col="violet")
plot(ts(rep(NA,T),start=-1,frequency=m),col=1,
ylim=c(0,max(Re(spec.hat[1,1,]),Re(spec.hat[2,2,]),Re(spec.hat[3,3,]))/6),
main="Periodogram",ylab="",xlab="",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(ts(Re(spec.hat[1,1,]),start=-1,frequency=m),col="orange")
lines(ts(Re(spec.hat[2,2,]),start=-1,frequency=m),col="green")
lines(ts(Re(spec.hat[3,3,]),start=-1,frequency=m),col="violet")
mtext("Cycles", side = 1, line = 1,outer=TRUE)
invisible(dev.off())
# Simulate a Gaussian bivariate process of sample size 200:
set.seed(1234)
T <- 200
N <- 2
phi <- .9
sigma <- 1
gamma.0 <- 1/(1-phi^2)
x.init <- sqrt(gamma.0)*rnorm(1)
x.next <- x.init
x.sim <- x.init
for(t in 1:T)
{
x.next <- phi * x.next + rnorm(1)
x.sim <- c(x.sim,x.next)
}
w.sim <- x.sim[-1] + sigma*rnorm(T)
x.sim <- cbind(x.sim[-(T+1)],w.sim)
# MDFA
q <- 20
grid <- T
m <- floor(grid/2)
# The Fourier frequencies
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))
# frf for 1-step ahead forecasting
frf.psi <- matrix(lambda.ft^{-1},nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat <- mdfa.pergram(x.sim,1)
fore.mdfa <- mdfa.unconstrained(frf.psi,spec.hat,q)
fore.udfa <- mdfa.unconstrained(frf.psi[1,1,,drop=FALSE],spec.hat[1,1,,drop=FALSE],q)
# apply the MDFA concurrent filter
x.fore.mdfa11 <- filter(x.sim[,1],fore.mdfa[[1]][1,1,],method="convolution",sides=1)
x.fore.mdfa12 <- filter(x.sim[,2],fore.mdfa[[1]][1,2,],method="convolution",sides=1)
x.fore.mdfa <- x.fore.mdfa11 + x.fore.mdfa12
# apply the univariate DFA concurrent filter
x.fore.udfa <- filter(x.sim[,1],fore.udfa[[1]][1,1,],method="convolution",sides=1)
# compare in-sample performance
print(c(mean((x.sim[(q+1):T,1] - x.fore.mdfa[q:(T-1)])^2),
mean((x.sim[(q+1):T,1] - x.fore.udfa[q:(T-1)])^2)))
# compare to criterion value
print(c(fore.mdfa[[2]][1,1],fore.udfa[[2]][1,1]))
par(mar=c(4,4,2,2)+0.1,cex.lab=.8,mfrow=c(1,1))
plot(ts(x.sim[-1,1]),ylab="",xlab="Time",yaxt="n",xaxt="n",col=grey(.7))
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
lines(x.fore.mdfa,col=grey(.5),lty=1)
lines(x.fore.udfa,col=1,lty=2)
invisible(dev.off())
# Set up loops over delta and sigma
delta.vals <- c(0,1,2,3,4)/4
sigma.vals <- c(0,.1,.5,1,2)
critmdfa.mat <- matrix(0,5,5,dimnames=list(c(0,1,2,3,4)/4,sigma.vals))
critudfa.mat <- matrix(0,5,5,dimnames=list(c(0,1,2,3,4)/4,sigma.vals))
for(delta in delta.vals) {
for(j in 1:5) {
sigma <- sigma.vals[j]
# Simulate a Gaussian bivariate process of sample size 2500:
set.seed(1234)
T <- 2500
N <- 2
phi <- .9
gamma.0 <- 1/(1-phi^2)
x.init <- sqrt(gamma.0)*rnorm(1)
x.next <- x.init
x.sim <- x.init
for(t in 1:T)
{
x.next <- phi * x.next + rnorm(1)
x.sim <- c(x.sim,x.next)
}
grid <- T
m <- floor(grid/2)
# define complex exponential at Fourier frequencies
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))
# frf for delta-step ahead forecasting
frf.psi <- matrix(lambda.ft^{-delta},nrow=1)
frf.psi <- array(frf.psi,c(1,1,grid))
nowcast.filter <- mdfa.coeff(frf.psi,-len,len)
x.target <- filter(x.sim,nowcast.filter[1,1,],method="convolution",sides=2)[(len+1):(T-len)]
w.sim <- x.target + sigma*rnorm(T-2*len)
x.sim <- cbind(x.sim[(len+1):(T-len)],w.sim)
# MDFA
q <- 20
grid <- T - 2*len
m <- floor(grid/2)
# The Fourier frequencies (recompute with smaller sample size)
lambda.ft <- exp(-1i*2*pi*grid^{-1}*(seq(1,grid) - (m+1)))
# frf for delta-step ahead forecasting
frf.psi <- matrix(lambda.ft^{-delta},nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat <- mdfa.pergram(x.sim,1)
fore.udfa <- mdfa.unconstrained(frf.psi[1,1,,drop=FALSE],spec.hat[1,1,,drop=FALSE],q)
if(j > 1) {
fore.mdfa <- mdfa.unconstrained(frf.psi,spec.hat,q)
} else { fore.mdfa <- fore.udfa }
# apply the MDFA concurrent filter
x.fore.mdfa11 <- filter(x.sim[,1],fore.mdfa[[1]][1,1,],method="convolution",sides=1)
if(j > 1) {
x.fore.mdfa12 <- filter(x.sim[,2],fore.mdfa[[1]][1,2,],method="convolution",sides=1)
} else { x.fore.mdfa12 <- 0*x.fore.mdfa11 }
x.fore.mdfa <- x.fore.mdfa11 + x.fore.mdfa12
# apply the univariate DFA concurrent filter
x.fore.udfa <- filter(x.sim[,1],fore.udfa[[1]][1,1,],method="convolution",sides=1)
# compare in-sample performance
#print(c(mean((x.target[-seq(1,q-1)] - x.fore.mdfa[-seq(1,q-1)])^2),
#	mean((x.target[-seq(1,q-1)] - x.fore.udfa[-seq(1,q-1)])^2)))
# store criterion value
i <- delta*4 + 1
critmdfa.mat[i,j] <- fore.mdfa[[2]][1,1]
critudfa.mat[i,j] <- fore.udfa[[2]][1,1]
}}
critumdfa.mat
critmdfa.mat
critudfa.mat
N <- 1
q <- 10
## level constraint case
constraint.mat <- matrix(rep(1,q),nrow=1)
constraint.vec <- diag(N)
constraint.qr <- qr(constraint.mat)
constraint.q <- qr.Q(constraint.qr)
constraint.r <- qr.R(constraint.qr)
constraint.pivot <- constraint.qr$pivot
constraint.ipivot <- sort.list(constraint.pivot)
M <- q - dim(constraint.r)[2] + dim(constraint.q)[2]
R.mat <- rbind(-solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE],
constraint.r[,(dim(constraint.q)[2]+1):q,drop=FALSE]),diag(q-M))
R.mat <- R.mat[constraint.ipivot,] %x% diag(N)
Q.mat <- rbind(solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE]) %*%
solve(constraint.q),matrix(0,q-M,M))
Q.mat <- (Q.mat[constraint.ipivot,] %x% diag(N)) %*% constraint.vec
print(R.mat)
## time shift constraint case
constraint.mat <- matrix(seq(0,q-1),nrow=1)
constraint.vec <- -diag(N)
constraint.qr <- qr(constraint.mat)
constraint.q <- qr.Q(constraint.qr)
constraint.r <- qr.R(constraint.qr)
constraint.pivot <- constraint.qr$pivot
constraint.ipivot <- sort.list(constraint.pivot)
M <- q - dim(constraint.r)[2] + dim(constraint.q)[2]
R.mat <- rbind(-solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE],
constraint.r[,(dim(constraint.q)[2]+1):q,drop=FALSE]),diag(q-M))
R.mat <- R.mat[constraint.ipivot,] %x% diag(N)
Q.mat <- rbind(solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE]) %*%
solve(constraint.q),matrix(0,q-M,M))
Q.mat <- (Q.mat[constraint.ipivot,] %x% diag(N)) %*% constraint.vec
print(R.mat)
## level and time shift constraint case
constraint.mat <- rbind(rep(1,q),seq(0,q-1))
constraint.vec <- rbind(diag(N),-diag(N))
constraint.qr <- qr(constraint.mat)
constraint.q <- qr.Q(constraint.qr)
constraint.r <- qr.R(constraint.qr)
constraint.pivot <- constraint.qr$pivot
constraint.ipivot <- sort.list(constraint.pivot)
M <- q - dim(constraint.r)[2] + dim(constraint.q)[2]
R.mat <- rbind(-solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE],
constraint.r[,(dim(constraint.q)[2]+1):q,drop=FALSE]),diag(q-M))
R.mat <- R.mat[constraint.ipivot,] %x% diag(N)
Q.mat <- rbind(solve(constraint.r[,1:(dim(constraint.q)[2]),drop=FALSE]) %*%
solve(constraint.q),matrix(0,q-M,M))
Q.mat <- (Q.mat[constraint.ipivot,] %x% diag(N)) %*% constraint.vec
print(R.mat)
# Simulate a VAR(1) of sample size 5000:
set.seed(1234)
T <- 5000
N <- 2
levels <- c(1,2)
slopes <- c(-2,1)/1000
phi.matrix <- rbind(c(1,.5),c(-.2,.3))
innovar.matrix <- diag(N)
true.psi <- var.par2pre(array(phi.matrix,c(2,2,1)))
gamma <- VARMAauto(array(phi.matrix,c(2,2,1)),NULL,innovar.matrix,10)
gamma.0 <- gamma[,,1]
x.init <- t(chol(gamma.0)) %*% rnorm(N)
x.next <- x.init
x.sim <- NULL
for(t in 1:T)
{
x.next <- phi.matrix %*% x.next + t(chol(innovar.matrix)) %*% rnorm(N)
x.sim <- cbind(x.sim,x.next)
}
x.sim <- ts(t(x.sim))
time.trend <- seq(1,T)
x.sim <- t(levels) %x% rep(1,T) + t(slopes) %x% seq(1,T) + x.sim
sim.ols <- lm(x.sim ~ time.trend)
x.resid <- sim.ols$residuals
# construct and apply low pass filter
mu <- pi/6
len <- 1000
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
#x.trend.ideal <- filter(x.sim,lp.filter,method="convolution",sides=2)[(len+1):(T-len),]
x.trend.ideal <- mvar.filter(x.sim,lp.filter)
mvar.filter
#x.trend.ideal <- filter(x.sim,lp.filter,method="convolution",sides=2)[(len+1):(T-len),]
x.trend.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get MDFA concurrent filter
q <- 30
grid <- T
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
spec.hat <- mdfa.pergram(x.resid,1)
lp.mdfa.uc <- mdfa.unconstrained(frf.psi,spec.hat,q)
lp.mdfa.lc <- mdfa.levelconstraint(frf.psi,spec.hat,q)
lp.mdfa.tsc <- mdfa.tsconstraint(frf.psi,spec.hat,q)
lp.mdfa.ltsc <- mdfa.ltsconstraint(frf.psi,spec.hat,q)
# case 1: apply the unconstrained MDFA concurrent filter
# x.trend.mdfa11 <- filter(x.sim[,1],lp.mdfa.uc[[1]][1,1,],method="convolution",sides=1)
# x.trend.mdfa12 <- filter(x.sim[,2],lp.mdfa.uc[[1]][1,2,],method="convolution",sides=1)
# x.trend.mdfa21 <- filter(x.sim[,1],lp.mdfa.uc[[1]][2,1,],method="convolution",sides=1)
# x.trend.mdfa22 <- filter(x.sim[,2],lp.mdfa.uc[[1]][2,2,],method="convolution",sides=1)
# x.trend.mdfa <- cbind(x.trend.mdfa11 + x.trend.mdfa12,x.trend.mdfa21 + x.trend.mdfa22)
# x.trend.mdfa <- x.trend.mdfa[(len+1):(T-len),]
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.uc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.uc[[2]])
# case 2: apply the lc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.lc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.lc[[2]])
lp.mdfa.uc <- mdfa.unconstrained(frf.psi,spec.hat,q)
lp.mdfa.lc <- mdfa.levelconstraint(frf.psi,spec.hat,q)
lp.mdfa.tsc <- mdfa.tsconstraint(frf.psi,spec.hat,q)
lp.mdfa.ltsc <- mdfa.ltsconstraint(frf.psi,spec.hat,q)
# case 1: apply the unconstrained MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.uc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.uc[[2]])
# case 2: apply the lc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.lc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.lc[[2]])
# case 3: apply the tsc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.tsc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.tsc[[2]])
# case 4: apply the ltsc MDFA concurrent filter
x.trend.mdfa <- mvar.filter(x.sim,lp.mdfa.ltsc[[1]])[(len-q+2):(T-q+1-len),]
# compare in-sample performance
print(c(mean((x.trend.ideal[,1] - x.trend.mdfa[,1])^2),
mean((x.trend.ideal[,2] - x.trend.mdfa[,2])^2)))
# compare to criterion value
diag(lp.mdfa.ltsc[[2]])
psi.sim <- c(2.17150287559847, -8.36795922528, -6.04133725367594,
0.0648981656699, -6.80849700177184, -6.66004335288479,
-0.00016098322952, 0.00051984185863)
psi.sim[7:8] <- c(0,0)
N <- 2
grid <- 1000
delta <- array(t(c(1,-1)) %x% diag(N),c(N,N,2))
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
Sigma.mu <- mu.sim[[2]]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),10,Inf)
Sigma.irr <- irr.sim[[2]]
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.frf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
par(mar=c(2,2,2,2)+0.1,cex.lab=.8,mfrow=c(N,N))
for(i in 1:N)
{
for(j in 1:N)
{
plot(ts(Re(trend.frf[i,j,]),frequency=grid/2,start=-1),ylim=c(0,1),ylab="",
xlab="Cycles",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
}
}
invisible(dev.off())
psi.sim <- c(1.8905590615422, -11.9288577633298, -12.0809347541079,
0.660897814610799, -8.2863379601304, -5.66645335346871,
-1.34743227511595e-05, -1.41207967213544e-05)
psi.sim[7:8] <- c(0,0)
N <- 2
grid <- 1000
delta <- array(t(c(1,-2,1)) %x% diag(N),c(N,N,3))
mu.sim <- mdfa.wnsim(psi.sim[1:3],rep(1,N),10,Inf)
Sigma.mu <- mu.sim[[2]]
irr.sim <- mdfa.wnsim(psi.sim[4:6],rep(1,N),10,Inf)
Sigma.irr <- irr.sim[[2]]
iden <- array(diag(N),c(N,N,1))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.irr <- mdfa.spectra(iden,iden,Sigma.irr,grid)
trend.frf <- mdfa.wkfrf(iden,delta,f.irr,f.mu)
par(mar=c(2,2,2,2)+0.1,cex.lab=.8,mfrow=c(N,N))
for(i in 1:N)
{
for(j in 1:N)
{
plot(ts(Re(trend.frf[i,j,]),frequency=grid/2,start=-1),ylim=c(0,1),ylab="",
xlab="Cycles",yaxt="n",xaxt="n")
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
}
}
invisible(dev.off())
psi.sim <- c(0.493586093056948, 0.178487258592539, 0.341217399125708,
0.399177274154249, 0.848325304642642, 0.68306879252262,
-2.3494687111314, -5.47534663726587, -6.69385117951384,
-6.08364145983965, 0.875100150810273, 0.221971271148611,
0.500866759201029, 0.340625016984097, 0.791037805495801,
0.985440262768576, -2.52890913740106, -4.29524634814519,
-5.98519527750281, -4.88659954275053, 0.0957466327314851,
0.201313350626488, 0.849351809157598, 0.48420520104336,
0.62643997675928, 1.13945063379914, -4.04217214895869,
-4.68919816059416, -4.73313805629826, -4.0627015759002,
0.923495751608401, -0.396067294450726, 0.244665046194039,
-0.36570474542918, 0.363995718736632, 0.758715172737758,
-3.05567431351817, -4.74337970092605, -4.96364133429136,
-5.06144086942249, 0.262963683605793, -0.181599400661918,
0.149795833258992, -0.105991649100357, 0.21503766242974,
-0.141649861043968, -2.07489346121933, -3.64302004053168,
-5.69277788172285, -5.3689470753418, 1.40718934367933,
-0.0085452878747676, -0.219886337273936, 0.0283662345070971,
1.23786259577472, 0.199834135215749, -4.53336362894347,
-4.70016052568401, -7.07530853221777, -6.03054443735399,
-0.0995506040524902, 0.116607848697947, 0.157899802233636,
-0.0363184981547607, 0.18385749297074, 0.329351477585333,
-2.1377604820296, -3.62882764786239, -5.11279846492415,
-3.62475631527416, 0.124305286145147, 0.0292507920421885,
-0.0873349194845382, 0.178977764316143, 0.484389128732254,
0.265835976421986, 1.87566939226944, 0.1445002084775,
-1.34264222816582, -0.305367634014929, -0.00488431480035087,
-0.000945659564684563, -0.00106126820173145, -0.000413658838890233)
psi.sim[81:84] <- c(0,0,0,0)
N <- 4
grid <- 1000
mu.sim <- mdfa.wnsim(psi.sim[1:10],rep(1,N),10,Inf)
Sigma.mu <- mu.sim[[2]]
seas1.sim <- mdfa.wnsim(psi.sim[11:20],rep(1,N),10,Inf)
Sigma.seas1 <- seas1.sim[[2]]
seas2.sim <- mdfa.wnsim(psi.sim[21:30],rep(1,N),10,Inf)
Sigma.seas2 <- seas2.sim[[2]]
seas3.sim <- mdfa.wnsim(psi.sim[31:40],rep(1,N),10,Inf)
Sigma.seas3 <- seas3.sim[[2]]
seas4.sim <- mdfa.wnsim(psi.sim[41:50],rep(1,N),10,Inf)
Sigma.seas4 <- seas4.sim[[2]]
seas5.sim <- mdfa.wnsim(psi.sim[51:60],rep(1,N),10,Inf)
Sigma.seas5 <- seas5.sim[[2]]
seas6.sim <- mdfa.wnsim(psi.sim[61:70],rep(1,N),10,Inf)
Sigma.seas6 <- seas6.sim[[2]]
irr.sim <- mdfa.wnsim(psi.sim[71:80],rep(1,N),10,Inf)
Sigma.irr <- irr.sim[[2]]
iden <- array(diag(N),c(N,N,1))
dpoly.1 <- c(1,-2*cos(pi/6),1)
dpoly.2 <- c(1,-2*cos(2*pi/6),1)
dpoly.3 <- c(1,-2*cos(3*pi/6),1)
dpoly.4 <- c(1,-2*cos(4*pi/6),1)
dpoly.5 <- c(1,-2*cos(5*pi/6),1)
dpoly.6 <- c(1,1)
dpoly.but1 <- polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but2 <- polymult(dpoly.1,polymult(dpoly.3,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but3 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.4,polymult(dpoly.5,dpoly.6))))
dpoly.but4 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.5,dpoly.6))))
dpoly.but5 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,dpoly.6))))
dpoly.but6 <- polymult(dpoly.1,polymult(dpoly.2,polymult(dpoly.3,polymult(dpoly.4,dpoly.5))))
delta.c <- array(t(c(1,-2,1)) %x% diag(N),c(N,N,3))
delta.but1 <- array(t(dpoly.but1) %x% diag(N),c(N,N,10))
delta.but2 <- array(t(dpoly.but2) %x% diag(N),c(N,N,10))
delta.but3 <- array(t(dpoly.but3) %x% diag(N),c(N,N,10))
delta.but4 <- array(t(dpoly.but4) %x% diag(N),c(N,N,10))
delta.but5 <- array(t(dpoly.but5) %x% diag(N),c(N,N,10))
delta.but6 <- array(t(dpoly.but6) %x% diag(N),c(N,N,11))
delta.seas <- array(t(rep(1,12)) %x% diag(N),c(N,N,12))
f.mu <- mdfa.spectra(iden,iden,Sigma.mu,grid)
f.seas1 <- mdfa.spectra(iden,delta.but1,Sigma.seas1,grid)
f.seas2 <- mdfa.spectra(iden,delta.but2,Sigma.seas2,grid)
f.seas3 <- mdfa.spectra(iden,delta.but3,Sigma.seas3,grid)
f.seas4 <- mdfa.spectra(iden,delta.but4,Sigma.seas4,grid)
f.seas5 <- mdfa.spectra(iden,delta.but5,Sigma.seas5,grid)
f.seas6 <- mdfa.spectra(iden,delta.but6,Sigma.seas6,grid)
f.irr <- mdfa.spectra(iden,delta.c,Sigma.irr,grid)
f.signal <- f.mu + f.irr
f.noise <- f.seas1 + f.seas2 + f.seas3 + f.seas4 + f.seas5 + f.seas6
sa.frf <- mdfa.wkfrf(delta.seas,delta.c,f.noise,f.signal)
par(mar=c(2,2,2,2)+0.1,cex.lab=.8,mfrow=c(N,N))
for(i in 1:N)
{
for(j in 1:N)
{
plot(ts(Re(sa.frf[i,j,]),frequency=grid/2,start=-1),ylim=c(-.5,1),ylab="",
xlab="Cycles",yaxt="n",xaxt="n")
abline(h=0,col=grey(.7))
axis(1,cex.axis=.5)
axis(2,cex.axis=.5)
}
}
invisible(dev.off())
# Simulate a Gaussian RW of sample size 5000:
set.seed(1234)
T.sim <- 5000
burn <- 1000
N <- 2
dpoly <- c(1,-1)
delta <- array(t(dpoly) %x% diag(N),c(N,N,2))
d <- length(dpoly) - 1
z.sim <- mdfa.wnsim(rep(0,3),rep(1,N),T.sim+burn,Inf)
Sigma <- z.sim[[2]]
x.sim <- mdfa.ucsim(delta,z.sim[[1]])[(burn+1-d):(T.sim+burn-d),]
# construct and apply ideal low-pass filter
mu <- pi/6
len <- 1000
lp.filter <- c(mu/pi,sin(seq(1,len)*mu)/(pi*seq(1,len)))
lp.filter <- c(rev(lp.filter),lp.filter[-1])
x.trend.ideal <- mvar.filter(x.sim,array(t(lp.filter) %x% diag(N),c(N,N,(2*len+1))))
# get MDFA concurrent filter
q <- 30
x.diff <- filter(x.sim,dpoly,method="convolution",sides=1)[(d+1):T.sim,]
spec.hat <- mdfa.pergram(x.diff,dpoly)
grid <- T.sim - d
m <- floor(grid/2)
# The Fourier frequencies
freq.ft <- 2*pi*grid^{-1}*(seq(1,grid) - (m+1))
# frf for ideal low-pass
frf.psi <- rep(0,grid)
frf.psi[abs(freq.ft) <= mu] <- 1
frf.psi <- matrix(frf.psi,nrow=1) %x% diag(N)
frf.psi <- array(frf.psi,c(N,N,grid))
constraints.mdfa <- mdfa.getconstraints(frf.psi,0,NULL,0*diag(N),q)
rm(list=ls())
library(xts)
# State-space models (will be replicated by MDFA)
library(dlm)
# Numerical package
library(numDeriv)
# Graphical package for recession-shading (empirical examples based on US-GDP)
library(tis)
#install.packages("devtools")
library(devtools)
# Load MDFA package from github
devtools::install_github("wiaidp/MDFA")
# MDFA package
library(MDFA)
library(RCurl)    # For getURL() and curl handler / cookie / google login
library(stringr)  # For str_trim() to trip whitespace from strings
library(Quandl)
require (Quandl)
#Quandl.api_key("ivVdJGV57TXA1RX5jgvp")
#  Tucker's libraries
library(expm)
library(R.utils)
library(xtable)
# set directory to GitHub/MDFA-Legacy
path.main <- paste(getwd(),"/Sweave/",sep="")
path.pgm <- paste(path.main,"Rnw/",sep="")
path.out <- paste(path.main,"Latex/",sep="")
## Load MDFA R codes #
sourceDirectory(path=paste(path.main,"RcodeTSM/",sep=""), modifiedOnly=FALSE)
script <- paste(path.pgm,"MDFA_Legacy",sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,"MDFA_Legacy.tex",sep=""))
