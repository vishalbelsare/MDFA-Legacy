# Copyright: Marc Wildi
# 30.10.2014
# http://blog.zhaw.ch/sef/
# http://www.mdfapartners.com/




### R code from vignette source 'C:/wia_desktop/Projekte/2014/MDFA-Legacy/Sweave/Rnw/MDFA_Legacy.Rnw'
### Encoding: ISO8859-1

###################################################
### code chunk number 1: init
###################################################
# Load packages
library(tseries)
library(xts)
# Specify hard-disk
disk_id<-"C"

# Set paths
path.main<-paste(disk_id,":\\wia_desktop\\Projekte\\2014\\MDFA-Legacy\\Sweave\\",sep="")
# Path to DFA-code: R-files are cut-and-pasted from DFA-book (they are identical)
path_DFA.pgm<-paste(path.main,"R\\I-DFA\\",sep="")
# Path to MDFA-code
path_MDFA.pgm<-paste(path.main,"R\\I-MDFA\\",sep="")
# Path to Latex-folder: all pdfs generated by the R-code are filed there
path.out<-paste(path.main,"Latex\\",sep="")
# Path to data 
path.dat<-paste(path.main,"Data\\",sep="")


###################################################
### code chunk number 2: dft
###################################################
per<-function(x,plot_T)
{
  len<-length(x)
  per<-0:(len/2)
  DFT<-per

  for (k in 0:(len/2))
  {
    cexp <- complex(arg=-(1:len)*2*pi*k/len)
    DFT[k+1]<-sum(cexp*x*sqrt(1/(2*pi*len)))
  }
  per<-abs(DFT)^2
  if (plot_T)
  {
    par(mfrow=c(2,1))
    plot(per,type="l",axes=F,xlab="Frequency",ylab="Periodogram",
    main="Periodogram")
    axis(1,at=1+0:6*len/12,labels=c("0","pi/6","2pi/6","3pi/6",
    "4pi/6","5pi/6","pi"))
    axis(2)
    box()
    plot(log(per),type="l",axes=F,xlab="Frequency",ylab="Log-periodogram",
    main="Log-periodogram")
    axis(1,at=1+0:6*len/12,labels=c("0","pi/6","2pi/6","3pi/6",
    "4pi/6","5pi/6","pi"))
    axis(2)
    box()
  }
  return(list(DFT=DFT,per=per))
}


###################################################
### code chunk number 3: dfa_ms
###################################################

# This function computes mean-square DFA-solutions
# L is the length of the MA filter,
# periodogram is the frequency weighting function in the DFA
# Gamma is the transferfunction of the symmetric filter (target) and
# Lag is the lag-parameter: Lag=0 implies real-time filtering, Lag=L/2
#     implies symmetric filter
# The function returns optimal coefficients as well as the transfer function of the
#     optimized real-time filter
dfa_ms<-function(L,periodogram,Lag,Gamma)
{

  K<-length(periodogram)-1
  X<-exp(-1.i*Lag*pi*(0:(K))/(K))*rep(1,K+1)*sqrt(periodogram)
  X_y<-exp(-1.i*Lag*pi*(0:(K))/(K))*rep(1,K+1)
  for (l in 2:L)          #l<-L<-21
  {
    X<-cbind(X,(cos((l-1-Lag)*pi*(0:(K))/(K))+
    1.i*sin((l-1-Lag)*pi*(0:(K))/(K)))*sqrt(periodogram))
    X_y<-cbind(X_y,(cos((l-1-Lag)*pi*(0:(K))/(K))+
    1.i*sin((l-1-Lag)*pi*(0:(K))/(K))))
  }
  xtx<-t(Re(X))%*%Re(X)+t(Im(X))%*%Im(X)
# MA-Filtercoefficients
  b<-as.vector(solve(xtx)%*%(t(Re(X_y))%*%(Gamma*periodogram)))
# Transferfunction
  trffkt<-1:(K+1)
  trffkt[1]<-sum(b)
  for (k in 1:(K))#k<-1
  {
    trffkt[k+1]<-(b%*%exp(1.i*k*(0:(length(b)-1))*pi/(K)))
  }
  return(list(b=b,trffkt=trffkt))
}



###################################################
### code chunk number 4: dfa_ms
###################################################
source(file=paste(path_DFA.pgm,"DFA_code.r",sep=""))


###################################################
### code chunk number 5: dfa_ms
###################################################
head(dfa_analytic)


###################################################
### code chunk number 6: dfa_ms
###################################################
set.seed(1)
len<-100
target<-arima.sim(list(ar=0.9),n=len)
explaining_2<-target+rnorm(len)
explaining<-cbind(target,explaining_2)
x<-cbind(target,explaining)
dimnames(x)[[2]]<-c("target","explaining 1","explaining 2")
head(x)


###################################################
### code chunk number 7: dfa_ms
###################################################
x<-cbind(x[,1],lag(x[,2:3],-1))
dimnames(x)[[2]]<-c("target","lagged explaining 1","lagged explaining 2")
head(x)


###################################################
### code chunk number 8: dfa_ms
###################################################
source(file=paste(path_MDFA.pgm,"DFT.r",sep=""))


###################################################
### code chunk number 9: dfa_ms
###################################################
spec_comp


###################################################
### code chunk number 10: dfa_ms
###################################################
source(file=paste(path_MDFA.pgm,"I-MDFA_new.r",sep=""))


###################################################
### code chunk number 11: dfa_ms
###################################################
head(mdfa_analytic_new)


###################################################
### code chunk number 12: dfa_ms
###################################################
weight_func<-matrix(1:6)
L<-2


###################################################
### code chunk number 13: dfa_ms
###################################################
K<-nrow(weight_func)-1
lambda<-0
Lag<-0
expweight<-0
i1<-F
i2<-F
weight_constraint<-rep(1/(nrow(weight_func)-1),nrow(weight_func)-1)
lambda_cross<-lambda_decay<-lambda_smooth<-0
lin_expweight<-F
shift_constraint<-rep(0,nrow(weight_func)-1)
grand_mean<-F
b0_H0<-NULL
chris_expweight<-F
weights_only<-F
weight_structure<-c(0,0)
white_noise<-F
synchronicity<-F
lag_mat<-matrix(rep(0:(L-1),nrow(weight_func)-1),nrow=L)


###################################################
### code chunk number 14: dfa_ms
###################################################
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))


###################################################
### code chunk number 15: exercise_dfa_ms_1
###################################################
# Generate series of length 2000
lenh<-2000
len<-120
# Specify the AR-coefficients
a_vec<-c(0.9,0,-0.9)
xh<-matrix(nrow=lenh,ncol=length(a_vec))
x<-matrix(nrow=len,ncol=length(a_vec))
yhat<-x
y<-x
# Generate series for each AR(1)-process
for (i in 1:length(a_vec))
{
# We want the same random-seed for each process  
  set.seed(10)
  xh[,i]<-arima.sim(list(ar=a_vec[i]),n=lenh)
}


###################################################
### code chunk number 16: exercise_dfa_ms_2
###################################################
# Extract 120 observations in the midddle of the longer series
x<-xh[lenh/2+(-len/2):((len/2)-1),]
# Compute the coefficients of the symmetric target filter
cutoff<-pi/6
# Order of approximation
ord<-1000
# Filter weights ideal trend (See DFA)
gamma<-c(cutoff/pi,(1/pi)*sin(cutoff*1:ord)/(1:ord))
# Compute the outputs yt of the (truncated) symmetric target filter
for (i in 1:length(a_vec))
{
  for (j in 1:120)
  {
    y[j,i]<-gamma[1:900]%*%xh[lenh/2+(-len/2)-1+(j:(j-899)),i]+
    gamma[2:900]%*%xh[lenh/2+(-len/2)+(j:(j+898)),i]
  }
}


###################################################
### code chunk number 17: exercise_dfa_ms_3
###################################################
plot_T<-F
periodogram<-matrix(ncol=3,nrow=len/2+1)
trffkt<-periodogram
perf_mat<-matrix(nrow=3,ncol=2)
dimnames(perf_mat)[[2]]<-c("Criterion Value","Mean-Square Sample Filter Error")
dimnames(perf_mat)[[1]]<-c("a1=0.9","a1=0","a1=-0.9")
# Filter length
L<-12
# Real-time design
Lag<-0
# Target ideal trend
Gamma<-c(1,(1:(len/2))<len/12)
b<-matrix(nrow=L,ncol=3)
# Compute real-time filters
for (i in 1:3)#i<-1
{
# Compute the periodogram based on the data (length 120)  
  periodogram[,i]<-per(x[,i],plot_T)$per
# Optimize filters
  filt<-dfa_ms(L,periodogram[,i],Lag,Gamma)
  trffkt[,i]<-filt$trffkt
  b[,i]<-filt$b
# Compute real-time outputs (we can use the longer series in order 
# to obtain estimates for time points t=1,...,11)
  for (j in 1:len)
    yhat[j,i]<-filt$b%*%xh[lenh/2+(-len/2)-1+j:(j-L+1),i]
# Compute criterion values
  perf_mat[i,1]<-(2*pi/length(Gamma))*abs(Gamma-trffkt[,i])^2%*%periodogram[,i]
}


###################################################
### code chunk number 18: exercise_dfa_ms_3
###################################################
for (i in 1:3)
{
# Compute criterion values
  perf_mat[i,1]<-(2*pi/length(Gamma))*abs(Gamma-trffkt[,i])^2%*%periodogram[,i]
}
perf_mat[,1]


###################################################
### code chunk number 19: exercise_dfa_ms_4
###################################################
# Compute time-domain MSE
mse<-apply(na.exclude((yhat-y))^2,2,mean)
perf_mat[,2]<-mse
perf_mat[,2]


###################################################
### code chunk number 20: z_dfa_ar1_output.pdf
###################################################
  library(Hmisc)
  require(xtable)
  #latex(cor_vec, dec = 1, , caption = "Example of using latex to create table",
  #center = "centering", file = "", floating = FALSE)
  xtable(perf_mat, dec = 1,digits=rep(3,dim(perf_mat)[2]+1),
  paste("Criterion values vs. sample (mean-square) filter errors",sep=""),
  label=paste("perf_mat",sep=""),
  center = "centering", file = "", floating = FALSE)


###################################################
### code chunk number 21: z_dfa_ar1_output.pdf
###################################################
file = paste("z_dfa_ar1_sym_output.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(3,1))
for (i in 1:3)   #i<-1
{
  ymin<-min(min(y[,i]),min(na.exclude(yhat)[,i]))
  ymax<-max(max(y[,i]),max(na.exclude(yhat)[,i]))
  ts.plot(yhat[,i],main=paste("Time-domain MSE = ",
  round(mse[i],3)," , Frequency-domain MSE = ",
  round(perf_mat[i,1],3),", a1 = ",a_vec[i],sep=""),col="blue",ylim=c(ymin,ymax),
  gpars=list(xlab="year", ylab=""))
  lines(y[,i],col="red")
  mtext("Real-time", side = 3, line = -1,at=len/2,col="blue")
  mtext("target", side = 3, line = -2,at=len/2,col="red")
}
dev.off()


###################################################
### code chunk number 22: z_dfa_ar1_output.pdf
###################################################
file = paste("z_dfa_ar1_sym_output", sep = "")
cat("\\begin{figure}[H]")
cat("\\begin{center}")
cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
cat("\\caption{Real-time filter output (blue) vs. targets (red) for a1=0.9 (top), a1=0 (middle) and a1=-0.9 (bottom)", sep = "")
cat("\\label{z_dfa_ar1_sym_output}}", sep = "")
cat("\\end{center}")
cat("\\end{figure}")


###################################################
### code chunk number 23: z_dfa_ar1_output.pdf
###################################################

omega_k<-pi*0:(len/2)/(len/2)
file = paste("z_dfa_ar1_amp_shift.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(2,2))
amp<-abs(trffkt)
shift<-Arg(trffkt)/omega_k
plot(amp[,1],type="l",main="Amplitude functions",
axes=F,xlab="Frequency",ylab="Amplitude",col="black",ylim=c(0,1))
lines(amp[,2],col="orange")
lines(amp[,3],col="green")
lines(Gamma,col="violet")
mtext("Amplitude a1=0.9", side = 3, line = -1,at=len/4,col="black")
mtext("Amplitude a1=0", side = 3, line = -2,at=len/4,col="orange")
mtext("Amplitude a1=-0.9", side = 3, line = -3,at=len/4,col="green")
mtext("Target", side = 3, line = -4,at=len/4,col="violet")
axis(1,at=c(0,1:6*len/12+1),labels=c("0","pi/6","2pi/6","3pi/6",
"4pi/6","5pi/6","pi"))
axis(2)
box()
plot(shift[,1],type="l",main="Time-shifts",
axes=F,xlab="Frequency",ylab="Shift",col="black",
ylim=c(0,max(na.exclude(shift[,3]))))
lines(shift[,2],col="orange")
lines(shift[,3],col="green")
lines(rep(0,len/2+1),col="violet")
mtext("Shift a1=0.9", side = 3, line = -1,at=len/4,col="black")
mtext("Shift a1=0", side = 3, line = -2,at=len/4,col="orange")
mtext("Shift a1=-0.9", side = 3, line = -3,at=len/4,col="green")
mtext("Target", side = 3, line = -4,at=len/4,col="violet")
axis(1,at=c(0,1:6*len/12+1),labels=c("0","pi/6","2pi/6","3pi/6",
"4pi/6","5pi/6","pi"))
axis(2)
box()
plot(periodogram[,1],type="l",main="Periodograms",
axes=F,xlab="Frequency",ylab="Periodogram",col="black",
ylim=c(0,max(periodogram[,3])/6))
lines(periodogram[,2],col="orange")
lines(periodogram[,3],col="green")
mtext("Periodogram a1=0.9", side = 3, line = -1,at=len/4,col="black")
mtext("Periodogram a1=0", side = 3, line = -2,at=len/4,col="orange")
mtext("Periodogram a1=-0.9", side = 3, line = -3,at=len/4,col="green")
axis(1,at=c(0,1:6*len/12+1),labels=c("0","pi/6","2pi/6","3pi/6",
"4pi/6","5pi/6","pi"))
axis(2)
box()
dev.off()


###################################################
### code chunk number 24: z_dfa_ar1_output.pdf
###################################################
file = paste("z_dfa_ar1_amp_shift.pdf", sep = "")
cat("\\begin{figure}[H]")
cat("\\begin{center}")
cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
cat("\\caption{Amplitude (top left), time-shifts (top-right) and periodograms (bottom left) for
a1=0.9 (black), a1=0 (orange) and a1=-0.9 (green)", sep = "")
cat("\\label{z_dfa_ar1_amp_shift}}", sep = "")
cat("\\end{center}")
cat("\\end{figure}")


###################################################
### code chunk number 25: dfa_ms
###################################################
dfa_ms


###################################################
### code chunk number 26: exercise_dfa_ms_4
###################################################
# Select the first process
i_process<-1
# Define the data-matrix:
# The first column must be the target series. 
# Columns 2,3,... are the explaining series. In a univariate setting
# target and explaining variable are identical
data_matrix<-cbind(x[,i_process],x[,i_process])
# Determine the in-sample period (fully in sample)
insample<-nrow(data_matrix)
# Compute the DFT by relying on the multivariate DFT-function: d=0 for stationary data (default settings)
weight_func<-spec_comp(insample, data_matrix, d)$weight_func 
# For this replication exercise we have to define a second DFT which is altered in frequency zero only 
weight_func_mod<-weight_func
# Frequency zero is scaled by sqrt(2) in order to be able to replicate DFA
weight_func_mod[1,]<-sqrt(2)*weight_func[1,]


###################################################
### code chunk number 27: exercise_dfa_ms_4
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Estimate filter coefficients: original (unmodified) DFTs
mdfa_obj_original<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)
# Estimate filter coefficients: modified DFTs (for replication purpose only)
mdfa_obj_mod<-mdfa_analytic_new(K,L,lambda,weight_func_mod,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)
# Filter coefficients: compare MDFA and previous DFA
b_mat<-cbind(mdfa_obj_original$b,mdfa_obj_mod$b,b[,i_process])
dimnames(b_mat)[[2]]<-c("MDFA original","MDFA modified","DFA")
dimnames(b_mat)[[1]]<-paste("lag ",0:(L-1),sep="")
b_mat


###################################################
### code chunk number 28: exercise_dfa_ms_4
###################################################
# Criterion value
criterion_mdfa<-mdfa_obj_original$rever
# DFA-numbers are stored in perf_mat
crit_mdfa<-matrix(c(criterion_mdfa,perf_mat[i_process,1],perf_mat[i_process,2]),ncol=1)
dimnames(crit_mdfa)[[1]]<-c("MDFA criterion (original)","DFA criterion","sample MSE")
dimnames(crit_mdfa)[[2]]<-"MSE estimates"
t(crit_mdfa)


###################################################
### code chunk number 29: exercise_dfa_ms_4
###################################################
set.seed(12)
# Select the AR(1)-process with coefficient 0.9
i_process<-1
# Scaling of the idiosyncratic noise
scale_idiosyncratic<-0.1
eps<-rnorm(nrow(xh))
indicator<-xh[,i_process]+scale_idiosyncratic*eps
# Data: first column=target, second column=x, third column=shifted (leading) indicator
data_matrix<-cbind(xh[,i_process],xh[,i_process],c(indicator[2:nrow(xh)],NA))
dimnames(data_matrix)[[2]]<-c("target","x","leading indicator")
# Extract 120 observations from the long sample
data_matrix_120<-data_matrix[lenh/2+(-len/2):((len/2)-1),]
head(data_matrix_120)


###################################################
### code chunk number 30: exercise_dfa_ms_4
###################################################
# Fully in sample
insample<-nrow(data_matrix_120)
# d=0 for stationary series: see default settings
weight_func<-spec_comp(insample, data_matrix_120, d)$weight_func 


###################################################
### code chunk number 31: exercise_dfa_ms_4
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Estimate filter coefficients
mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)
# Filter coefficients
b_mat<-mdfa_obj$b
dimnames(b_mat)[[2]]<-c("x","leading indicator")
dimnames(b_mat)[[1]]<-paste("Lag ",0:(L-1),sep="")
head(b_mat)


###################################################
### code chunk number 32: exercise_dfa_ms_4
###################################################
# Criterion value
mdfa_obj$rever


###################################################
### code chunk number 33: exercise_dfa_ms_4
###################################################
yhat_multivariate<-rep(NA,len)
for (j in 1:len)
  yhat_multivariate[j]<-sum(apply(b_mat*data_matrix[lenh/2+(-len/2)-1+j:(j-L+1),2:3],1,sum))


###################################################
### code chunk number 34: exercise_dfa_ms_4
###################################################
perf_mse<-matrix(c(mean(na.exclude((yhat_multivariate-y[,i_process]))^2),mean(na.exclude((yhat[,i_process]-y[,i_process]))^2)),nrow=1)
dimnames(perf_mse)[[2]]<-c("bivariate MDFA","DFA")
dimnames(perf_mse)[[1]]<-"Sample MSE"
perf_mse


###################################################
### code chunk number 35: z_mdfadfa_ar1_output.pdf
###################################################
file = paste("z_mdfadfa_ar1_sym_output.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
i<-1
ymin<-min(min(y[,i]),min(na.exclude(yhat)[,i]))
ymax<-max(max(y[,i]),max(na.exclude(yhat)[,i]))
ts.plot(yhat[,i],main=paste("Sample MSE MDFA: ",ylab="",
round(perf_mse[1],3),", DFA: ",round(perf_mse[2],3),sep=""),col="blue",ylim=c(ymin,ymax))
lines(y[,i],col="red")
lines(yhat_multivariate,col="green")
mtext("DFA", side = 3, line = -2,at=len/2,col="blue")
mtext("target", side = 3, line = -1,at=len/2,col="red")
mtext("MDFA", side = 3, line = -3,at=len/2,col="green")
dev.off()


###################################################
### code chunk number 36: z_mdfadfa_ar1_output.pdf
###################################################
file = paste("z_mdfadfa_ar1_sym_output", sep = "")
cat("\\begin{figure}[H]")
cat("\\begin{center}")
cat("\\includegraphics[height=3in, width=6in]{", file, "}\n",sep = "")
cat("\\caption{Target (red) vs. DFA (blue) and bivariate MDFA (green) for the first process (a1=0.9)", sep = "")
cat("\\label{z_mdfadfa_ar1_sym_output}}", sep = "")
cat("\\end{center}")
cat("\\end{figure}")


###################################################
### code chunk number 37: exercise_dfa_ms_4
###################################################
# Inverse SNR: the variance of the standardized noise is one: we thus normalize by 
# the standard deviation of the data x (second column of the data matrix) 
scale_idiosyncratic_vec<-c(0,0.1,0.5,1,2)/sqrt(var(data_matrix_120[,2]))
# We select fractional leads: multiples of 0.25 
# A fractional lead of 0.25 corresponds roughly to a week on a monthly time scale
delta_vec<-0.25*0:4


###################################################
### code chunk number 38: exercise_dfa_ms_4
###################################################
# Initialize the performance matrix
lead_snr_mat<-matrix(ncol=length(scale_idiosyncratic_vec),nrow=length(delta_vec))
dimnames(lead_snr_mat)[[2]]<-paste("1/SNR=",sqrt(var(data_matrix_120[,1]))*scale_idiosyncratic_vec,paste="")
dimnames(lead_snr_mat)[[2]][1]<-paste("Univ. design: ",dimnames(lead_snr_mat)[[2]][1],sep="")
dimnames(lead_snr_mat)[[1]]<-paste("Shift ",delta_vec,paste="")
# Generate the idiosyncratic noise
set.seed(20)
eps<-rnorm(nrow(data_matrix_120))
# Loop over all combinations of leads and SNR-ratios
for (i in 1:length(scale_idiosyncratic_vec))#i<-1
{
  for (j in 1:length(delta_vec))#j<-1
  {
# Add the (suitably scaled) noise: no lead yet.    
    indicator<-data_matrix_120[,2]+scale_idiosyncratic_vec[i]*eps
# Overwrite the indicator column with the new time series
    data_matrix_120[,3]<-indicator
# Compute the DFTs (full in-sample, for stationary series d=0)
    insample<-nrow(data_matrix_120)
    weight_func<-spec_comp(insample, data_matrix_120, d)$weight_func
# Compute the discrete frequency-grid omega_k: from zero to pi
    omega_k<-(0:(nrow(weight_func)-1))*pi/(nrow(weight_func)-1)
# Introduce the fractional time-shift by rotation of the DFT of the indicator (last column)
    weight_func[,ncol(weight_func)]<-exp(-1.i*delta_vec[j]*omega_k)*weight_func[,ncol(weight_func)]
# If the idiosyncratic noise is zero, then we use a univariate design
  if (i==1)
     weight_func<-weight_func[,-2]
# Compute optimal filters and derive the (frequency-domain) MSE
    mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)
# Store the MSE
    lead_snr_mat[j,i]<-mdfa_obj$rever
  }
}


###################################################
### code chunk number 39: z_dfa_ar1_output.pdf
###################################################
  library(Hmisc)
  require(xtable)
  #latex(cor_vec, dec = 1, , caption = "Example of using latex to create table",
  #center = "centering", file = "", floating = FALSE)
  xtable(lead_snr_mat, dec = 1,digits=rep(3,dim(lead_snr_mat)[2]+1),
  paste("Effect of lead and of (inverse) signal-to-noise ratio on filter MSE",sep=""),
  label=paste("lead_snr_mat",sep=""),
  center = "centering", file = "", floating = FALSE)


###################################################
### code chunk number 40: Filter_revisions.Rnw:14-16
###################################################
US_GDP<-read.csv(paste(path.dat,"US_GDP.csv",sep=""),header=T)
US_GDP_wp<-read.csv(paste(path.dat,"US_GDP_wp.csv",sep=""),header=T,sep=";")


###################################################
### code chunk number 41: US_GDP
###################################################
  library(Hmisc)
  require(xtable)
  #latex(cor_vec, dec = 1, , caption = "Example of using latex to create table",
  #center = "centering", file = "", floating = FALSE)
  xtable(US_GDP,
  paste("US-GDP: yearly vintages starting in Q1 2009 and ending in Q1 2013",sep=""),
  label=paste("US_GDP",sep=""),
  center = "centering", file = "", floating = FALSE)


###################################################
### code chunk number 42: dfa_ms
###################################################
head(dfa_ms)
#head(mdfa_analytic_new)


###################################################
### code chunk number 43: Filter_revisions.Rnw:89-105
###################################################
# Generate series
set.seed(10)
len<-120
a_vec<-c(0.9,0,-0.9)
x<-matrix(nrow=len,ncol=3)
plot_T<-F
yhat<-x
periodogram<-matrix(ncol=3,nrow=len/2+1)
trffkt<-periodogram
# Generate series
for (i in 1:3)
{
  set.seed(10)
  x[,i]<-arima.sim(list(ar=a_vec[i]),n=len)
}
Gamma<-c(1,(1:(len/2))<len/12)


###################################################
### code chunk number 44: Filter_revisions.Rnw:108-127
###################################################
L<-13
yhat_Lag<-array(dim=c(len,3,L/2+2))
trffkt<-array(dim=c(len/2+1,3,L/2+2))
b<-array(dim=c(L,3,L/2+2))
# Compute real-time filters for Lag=,...,L/2 and for the above three AR-processes
for (i in 1:3)
{
  periodogram[,i]<-per(x[,i],plot_T)$per
  for (Lag in 0:((L/2)+1))
  {
# Optimize filters
    filt<-dfa_ms(L,periodogram[,i],Lag,Gamma)
    trffkt[,i,Lag+1]<-filt$trffkt
    b[,i,Lag+1]<-filt$b
# Compute outputs
    for (j in L:len)
      yhat_Lag[j,i,Lag+1]<-filt$b%*%x[j:(j-L+1),i]
  }
}


###################################################
### code chunk number 45: Filter_revisions.Rnw:130-195
###################################################
# Discrete frequency grid
omega_k<-pi*0:(len/2)/(len/2)
colo<-rainbow(L/2+2)
file = paste("z_dfa_ar1_amp_shift_Lag_0.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(2,2))
amp<-abs(trffkt)
shift<-Arg(trffkt)/omega_k
for (i in 2:2)
{
  ymin<-min(amp[,i,],na.rm=T)
  ymax<-max(amp[,i,],na.rm=T)
  plot(amp[,i,1],type="l",main=paste("Amplitude functions, a1 = ",a_vec[i],sep=""),
  axes=F,xlab="Frequency",ylab="Amplitude",col=colo[1],ylim=c(ymin,ymax))
  mtext("Lag=0", side = 3, line = -1,at=len/4,col=colo[1])
  for (j in 2:(L/2+2))
  {
    lines(amp[,i,j],col=colo[j])
    mtext(paste("Lag=",j-1,sep=""), side = 3, line = -j,at=len/4,col=colo[j])
  }
  axis(1,at=c(0,1:6*len/12+1),labels=c("0","pi/6","2pi/6","3pi/6",
  "4pi/6","5pi/6","pi"))
  axis(2)
  box()
  ymin<-min(shift[,i,],na.rm=T)
  ymax<-max(shift[,i,],na.rm=T)
  plot(shift[,i,1],type="l",main=paste("Time-Shifts, a1 = ",a_vec[i],sep=""),
  axes=F,xlab="Frequency",ylab="Shift",col=colo[1],ylim=c(ymin,ymax))
  mtext("Lag=0", side = 3, line = -1,at=len/4,col=colo[1])
  for (j in 2:(L/2+2))
  {
    lines(shift[,i,j],col=colo[j])
    mtext(paste("Lag=",j-1,sep=""), side = 3, line = -j,at=len/4,col=colo[j])
  }
  axis(1,at=c(0,1:6*len/12+1),labels=c("0","pi/6","2pi/6","3pi/6",
  "4pi/6","5pi/6","pi"))
  axis(2)
  box()
  ymin<-min(b[,i,],na.rm=T)
  ymax<-max(b[,i,],na.rm=T)
  plot(b[,i,1],col=colo[1],ylim=c(ymin,ymax),main=paste("Filter coefficients"),
  ylab="Output",xlab="lag",axes=F,typ="l")
  mtext("Lag=0", side = 3, line = -1,at=L/2,col=colo[1])
  for (j in 2:(L/2+2))
  {
    lines(b[,i,j],col=colo[j],type="l")
    mtext(paste("Lag=",j-1,sep=""), side = 3, line = -j,at=L/2,col=colo[j])
  }
  axis(1,at=1:L,labels=-1+1:L)
  axis(2)
  box()

  ymin<-min(yhat_Lag[,i,],na.rm=T)
  ymax<-max(yhat_Lag[,i,],na.rm=T)
  ts.plot(yhat_Lag[,i,1],col=colo[1],ylim=c(ymin,ymax),
  main=paste("Output series"),ylab="Output")
  mtext("Lag=0", side = 3, line = -1,at=len/2,col=colo[1])  
  for (j in 2:(L/2+2))
  {
    lines(yhat_Lag[,i,j],col=colo[j])
    mtext(paste("Lag=",j-1,sep=""), side = 3, line = -j,at=len/2,col=colo[j])
  }

}
dev.off()


###################################################
### code chunk number 46: z_dfa_ar1_amp_shift_Lag_0.pdf
###################################################
  file = paste("z_dfa_ar1_amp_shift_Lag_0.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (left) and time-shift (right) functions as a function of Lag (rainbow colors) for
  the white noise process (a1=0)", sep = "")
  cat("\\label{z_dfa_ar1_amp_shift_Lag_0}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 47: Filter_revisions.Rnw:238-250
###################################################
vintage<-array(dim=c(len,3,len))
# For each of the three AR(1)-processes We compute the vintage series
for (i in 1:3)
{
  for (j in L:len)#j<-L
  {
    vintage[(j-as.integer(L/2)):j,i,j]<-yhat_Lag[j,i,(as.integer(L/2)+1):1]
    vintage[1:(j-as.integer(L/2)-1),i,j]<-
    yhat_Lag[(as.integer(L/2)+1):(j-1),i,as.integer(L/2)+1]
  }
}
number_vint<-6


###################################################
### code chunk number 48: Filter_revisions.Rnw:253-258
###################################################
# We select the third DGP with a1=-0.9
i<-3
vintage_triangle<-vintage[,i,]
dimnames(vintage_triangle)[[2]]<-paste("Publ. ",1:len,sep="")
dimnames(vintage_triangle)[[1]]<-paste("Target ",1:len,sep="")


###################################################
### code chunk number 49: vintage_triangle
###################################################
  library(Hmisc)
  require(xtable)
  #latex(cor_vec, dec = 1, , caption = "Example of using latex to create table",
  #center = "centering", file = "", floating = FALSE)
  xtable(vintage_triangle[(len-number_vint):len,(len-number_vint):len], dec = 1,digits=rep(3,dim(vintage_triangle[(len-number_vint):len,(len-number_vint):len])[2]+1),
  paste("Last few vintages for the AR(1)-process with a1=-0.9: columns correspond to vintages and are indexed
  by corresponding publication dates; rows correspond to revisions of estimates for a fixed historical target date; diagonals correspond to releases",sep=""),
  label=paste("vintage_triangle",sep=""),
  center = "centering", file = "", floating = FALSE)


###################################################
### code chunk number 50: Filter_revisions.Rnw:301-319
###################################################
colo<-rainbow(len)
file = paste("z_vintages.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(3,1))
for (i in 1:3)
{
  ymin<-min(vintage[,i,],na.rm=T)
  ymax<-max(vintage[,i,],na.rm=T)
  ts.plot(vintage[,i,L],col=colo[1],ylim=c(ymin,ymax),
  main=paste("Tentacle plot: vintages and full revision sequence,
  a1 = ",a_vec[i],sep=""),ylab="Vintages")
  for (j in (L+1):len)
  {
    lines(vintage[,i,j],col=colo[j])
  }
  lines(vintage[,i,len],col="red",lwd=2)
}
dev.off()


###################################################
### code chunk number 51: z_vintages.pdf
###################################################
  file = paste("z_vintages.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Tentacle plot: full historical revision sequence for
  a1=0.9 (top), a1=0 (middle) and a1=-0.9 (bottom). Final release is emphasized in bold red", sep = "")
  cat("\\label{z_vintages}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 52: Filter_revisions.Rnw:335-360
###################################################
file = paste("z_vintages_2.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(2,1))
i<-2
ymin<-min(vintage[,i,],na.rm=T)
ymax<-max(vintage[,i,],na.rm=T)
ts.plot(vintage[,i,L],col=colo[1],ylim=c(ymin,ymax),
main="Vintages: full revision sequence and final release (black)",ylab="Vintages")
for (j in (L+1):len)
{
  lines(vintage[,i,j],col=colo[j])
}
lines(vintage[,i,len],col="black",lwd=2)
i<-2
ymin<-min(vintage[,i,],na.rm=T)
ymax<-max(vintage[,i,],na.rm=T)
ts.plot(vintage[,i,L],col=colo[1],ylim=c(ymin,ymax),
main="Vintages: full revision sequence and real-time initial release (black)",
ylab="Vintages")
for (j in (L+1):len)
{
  lines(vintage[,i,j],col=colo[j])
}
lines(yhat_Lag[,i,1],col="black",lty=1)
dev.off()


###################################################
### code chunk number 53: z_vintages_2.pdf
###################################################
  file = paste("z_vintages_2.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Vintages: full historical revision sequence in the case of the white noise process", sep = "")
  cat("\\label{z_vintages_2}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 54: Filter_revisions.Rnw:383-394
###################################################
set.seed(12)
# Select the AR(1)-process with coefficient 0.9
i_process<-2
# Scaling of the idiosyncratic noise
scale_idiosyncratic<-0.1
eps<-rnorm(nrow(x))
indicator<-x[,i_process]+scale_idiosyncratic*eps
# Data: first column=target, second column=x, third column=shifted (leading) indicator
data_matrix_120<-cbind(x[,i_process],x[,i_process],c(indicator[2:nrow(x)],indicator[nrow(x)]))
dimnames(data_matrix_120)[[2]]<-c("target","x","leading indicator")
head(data_matrix_120)


###################################################
### code chunk number 55: exercise_dfa_ms_4
###################################################
# Fully in sample
insample<-nrow(data_matrix_120)
# d=0 for stationary series: see default settings
weight_func<-spec_comp(insample, data_matrix_120, d)$weight_func


###################################################
### code chunk number 56: exercise_dfa_ms_4
###################################################
yhat_Lag_mdfa<-matrix(nrow=len,ncol=L/2+2)
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Estimate filter coefficients
for (Lag in 0:((L/2)))#Lag<-6  mdfa_obj$rever
{
  mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)
  print(paste("Lag=",Lag," Criterion=",round(mdfa_obj$rever,4),sep=""))
# Filter coefficients
  b_mat<-mdfa_obj$b
# Compute outputs
  for (j in L:len)
    yhat_Lag_mdfa[j,Lag+1]<-sum(apply(b_mat*data_matrix_120[j:(j-L+1),2:3],1,sum))
}


###################################################
### code chunk number 57: Filter_revisions.Rnw:423-431
###################################################
vintage_mdfa<-matrix(nrow=len,ncol=len)
# For each of the three AR(1)-processes We compute the vintage series
for (j in L:len)#j<-len
{
  vintage_mdfa[(j-as.integer(L/2)):j,j]<-yhat_Lag_mdfa[j,(as.integer(L/2)+1):1]
  vintage_mdfa[1:(j-as.integer(L/2)-1),j]<-
  yhat_Lag_mdfa[(as.integer(L/2)+1):(j-1),as.integer(L/2)+1]
}


###################################################
### code chunk number 58: Filter_revisions.Rnw:434-456
###################################################
file = paste("z_vintages_mdfa.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)
par(mfrow=c(2,1))
ymin<-min(vintage_mdfa,na.rm=T)
ymax<-max(vintage_mdfa,na.rm=T)
ts.plot(vintage_mdfa[,L],col=colo[1],ylim=c(ymin,ymax),
main="Vintages: full revision sequence and final release (black)",ylab="Vintages")
for (j in (L+1):len)
{
  lines(vintage_mdfa[,j],col=colo[j])
}
lines(vintage_mdfa[,len],col="black",lwd=2)
ymin<-min(vintage_mdfa,na.rm=T)
ymax<-max(vintage_mdfa,na.rm=T)
ts.plot(vintage_mdfa[,L],col=colo[1],ylim=c(ymin,ymax),
main="Vintages: full revision sequence and final release (black)",ylab="Vintages")
for (j in (L+1):len)
{
  lines(vintage_mdfa[,j],col=colo[j])
}
lines(yhat_Lag_mdfa[,1],col="black",lwd=1)
dev.off()


###################################################
### code chunk number 59: z_vintages_mdfa.pdf
###################################################
  file = paste("z_vintages_mdfa.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Vintages: full historical revision sequence in the case of the white noise process", sep = "")
  cat("\\label{z_vintages_mdfa}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 60: exercise_constraint
###################################################
# Filter length
L<-5
set.seed(1)
# The first three coefficients are random numbers
b<-rnorm(1:(L-2))
# Define the constants: the following are classical restrictions (amplitude is 1 and time shift is zero)
w<-1
s<-0
b<-c(b,(L-1-s)*w-(L-1:(L-2))%*%b,(2+s-L)*w+(L-2:(L-1))%*%b)


###################################################
### code chunk number 61: exercise_constraint
###################################################
# Level constraint
sum(b)-w
# time-shift constraint
sum(b*0:(L-1))/sum(b)-s


###################################################
### code chunk number 62: Constraints.Rnw:424-453
###################################################
# Generate series
#rm(list=ls())
set.seed(10)
len<-120
a_vec<-c(0.9,0,-0.9)
x<-matrix(nrow=len,ncol=3)
plot_T<-F
yhat<-x
periodogram<-matrix(ncol=3,nrow=len/2+1)
trffkt<-periodogram
# Generate series
for (i in 1:3)
{
  set.seed(10)
  x[,i]<-arima.sim(list(ar=a_vec[i]),n=len)
}
# Target
Gamma<-c(1,(1:(len/2))<len/12)
set.seed(12)
# Select the AR(1)-process with coefficient 0.9
i_process<-3
# Scaling of the idiosyncratic noise
scale_idiosyncratic<-0.1
eps<-rnorm(nrow(x))
indicator<-x[,i_process]+scale_idiosyncratic*eps
# Data: first column=target, second column=x, third column=shifted (leading) indicator
data_matrix_120<-cbind(x[,i_process],x[,i_process],c(indicator[2:nrow(x)],indicator[nrow(x)]))
dimnames(data_matrix_120)[[2]]<-c("target","x","leading indicator")
head(data_matrix_120)


###################################################
### code chunk number 63: exercise_mdfa_ms_1
###################################################
# Filter length
L<-13
# Fully in sample
insample<-nrow(data_matrix_120)
# d=0 for stationary series: see default settings
weight_func<-spec_comp(insample, data_matrix_120, d)$weight_func
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Source a convenient plot function
source(file=paste(path_MDFA.pgm,"mplot_func.r",sep=""))

# Estimate filter coefficients
mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)

file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2F.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)

par(mfrow = c(2, 1))
# amplitude functions
mplot <- abs(mdfa_obj$trffkt)
# x-axis
freq_axe <- rep(NA, K + 1)
freq_axe[1] <- 0
freq_axe[1 + (1 : 6) * K / 6] <- c(paste0(c("", 2 : 5), "pi/6"), "pi")
ax <- freq_axe
# colors, title and additional titles
insamp <- 1.e+90
colo <- NULL
plot_title <- "Amplitude Functions"
title_more <- colnames(x[, -1])
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
# time-shift
mplot <- Arg(t(sign(apply(mdfa_obj$b, 2, sum)) * t(mdfa_obj$trffkt))) /
      ((0 : (nrow(mdfa_obj$trffkt) - 1)) * pi / (nrow(mdfa_obj$trffkt) - 1))
# We use the exact formula for the time-shift in frequency zero
mplot[1, ] <- apply(mdfa_obj$b * ((0 : (L - 1))), 2, sum) / 
      apply(mdfa_obj$b, 2, sum)
plot_title <- "Time-Shift"
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
ts.plot(mdfa_obj$b)
dev.off()


###################################################
### code chunk number 64: z_mdfa_ar1_amp_shift_Lag_0_iF_i2F.pdf
###################################################
  file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2F.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (top) and time-shift (bottom) functions: unconstrained i1=I2=F", sep = "")
  cat("\\label{z_mdfa_ar1_amp_shift_Lag_0_iF_i2F}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 65: exercise_dfa_ms_2
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Impose level constraint
i1<-T
# Constraints: for series 1 and 2
weight_constraint<-c((1+sqrt(5))/2,-sqrt(2))

mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)

file = paste("z_mdfa_ar1_amp_shift_Lag_0_iT_i2F.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)

par(mfrow = c(2, 1))
# amplitude functions
mplot <- abs(mdfa_obj$trffkt)
# x-axis
freq_axe <- rep(NA, K + 1)
freq_axe[1] <- 0
freq_axe[1 + (1 : 6) * K / 6] <- c(paste0(c("", 2 : 5), "pi/6"), "pi")
ax <- freq_axe
# colors, title and additional titles
insamp <- 1.e+90
colo <- NULL
plot_title <- "Amplitude Functions"
title_more <- colnames(x[, -1])
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
# time-shift
mplot <- Arg(t(sign(apply(mdfa_obj$b, 2, sum)) * t(mdfa_obj$trffkt))) /
      ((0 : (nrow(mdfa_obj$trffkt) - 1)) * pi / (nrow(mdfa_obj$trffkt) - 1))
# We use the exact formula for the time-shift in frequency zero
mplot[1, ] <- apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum)
plot_title <- "Time-Shift"
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
dev.off()
print(c("Level restrictions", round(apply(mdfa_obj$b,2,sum),4)))


###################################################
### code chunk number 66: z_mdfa_ar1_amp_shift_Lag_0_iT_i2F.pdf
###################################################
  file = paste("z_mdfa_ar1_amp_shift_Lag_0_iT_i2F.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (top) and time-shift (bottom) functions: i1=T,i2=F", sep = "")
  cat("\\label{z_mdfa_ar1_amp_shift_Lag_0_iT_i2F}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 67: exercise_dfa_ms_3
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))#b0_H0
# Estimate filter coefficients: note that i1<-F by sourcing the default parameters
i2<-T
shift_constraint<-c(exp(1),-pi)

mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)

file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2T.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)

par(mfrow = c(2, 1))
# amplitude functions
mplot <- abs(mdfa_obj$trffkt)
# x-axis
freq_axe <- rep(NA, K + 1)
freq_axe[1] <- 0
freq_axe[1 + (1 : 6) * K / 6] <- c(paste0(c("", 2 : 5), "pi/6"), "pi")
ax <- freq_axe
# colors, title and additional titles
insamp <- 1.e+90
colo <- NULL
plot_title <- "Amplitude Functions"
title_more <- colnames(x[, -1])
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
# time-shift
mplot <- Arg(t(sign(apply(mdfa_obj$b, 2, sum)) * t(mdfa_obj$trffkt))) /
      ((0 : (nrow(mdfa_obj$trffkt) - 1)) * pi / (nrow(mdfa_obj$trffkt) - 1))
# We use the exact formula for the time-shift in frequency zero
mplot[1, ] <- apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum)
plot_title <- "Time-Shift"
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
dev.off()
print(c("Time-shift restrictions",round(apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum),4)))


###################################################
### code chunk number 68: z_mdfa_ar1_amp_shift_Lag_0_iF_i2T.pdf
###################################################
  file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2T.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (top) and time-shift (bottom) functions: i1=F,i2=T", sep = "")
  cat("\\label{z_mdfa_ar1_amp_shift_Lag_0_iF_i2T}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 69: exercise_mdfa_ms_4
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))
# Impose both constraints
i1<-T
i2<-T
# Specify the constraints
weight_constraint<-c((1+sqrt(5))/2,-sqrt(2))
shift_constraint<-c(exp(1),-pi)

mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)

file = paste("z_mdfa_ar1_amp_shift_Lag_0_iT_i2T.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)

par(mfrow = c(2, 1))
# amplitude functions
mplot <- abs(mdfa_obj$trffkt)
# x-axis
freq_axe <- rep(NA, K + 1)
freq_axe[1] <- 0
freq_axe[1 + (1 : 6) * K / 6] <- c(paste0(c("", 2 : 5), "pi/6"), "pi")
ax <- freq_axe
# colors, title and additional titles
insamp <- 1.e+90
colo <- NULL
plot_title <- "Amplitude Functions"
title_more <- colnames(x[, -1])
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
# time-shift
mplot <- Arg(t(sign(apply(mdfa_obj$b, 2, sum)) * t(mdfa_obj$trffkt))) /
      ((0 : (nrow(mdfa_obj$trffkt) - 1)) * pi / (nrow(mdfa_obj$trffkt) - 1))
# We use the exact formula for the time-shift in frequency zero
mplot[1, ] <- apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum)
plot_title <- "Time-Shift"
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
dev.off()
print(c("Level restrictions", round(apply(mdfa_obj$b,2,sum),4)))
print(c("Time-shift restrictions",round(apply(mdfa_obj$b*(Lag:(L-1+Lag)),2,sum)/apply(mdfa_obj$b, 2, sum),4)))


###################################################
### code chunk number 70: z_mdfa_ar1_amp_shift_Lag_0_iT_i2T.pdf
###################################################
  file = paste("z_mdfa_ar1_amp_shift_Lag_0_iT_i2T.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (top) and time-shift (bottom) functions: i1=i2=T", sep = "")
  cat("\\label{z_mdfa_ar1_amp_shift_Lag_0_iT_i2T}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 71: exercise_dfa_ms_3
###################################################
# Source the default (MSE-) parameter settings
source(file=paste(path_MDFA.pgm,"control_default.r",sep=""))#b0_H0
# Estimate filter coefficients: note that i1<-F by sourcing the default parameters
i2<-T
Lag<--2
shift_constraint<-c(0,2)

mdfa_obj<-mdfa_analytic_new(K,L,lambda,weight_func,Lag,Gamma,expweight,cutoff,i1,i2,weight_constraint,lambda_cross,lambda_decay,lambda_smooth,lin_expweight,shift_constraint,grand_mean,b0_H0,chris_expweight,weights_only=F,weight_structure,white_noise,synchronicity,lag_mat)

b_mat<-mdfa_obj$b
trffkt_mdfa<-mdfa_obj$trffkt

file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2T_Lag.pdf", sep = "")
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 6, height = 6)

par(mfrow = c(2, 1))
# amplitude functions
mplot <- abs(mdfa_obj$trffkt)
# x-axis
freq_axe <- rep(NA, K + 1)
freq_axe[1] <- 0
freq_axe[1 + (1 : 6) * K / 6] <- c(paste0(c("", 2 : 5), "pi/6"), "pi")
ax <- freq_axe
# colors, title and additional titles
insamp <- 1.e+90
colo <- NULL
plot_title <- "Amplitude Functions"
title_more <- colnames(x[, -1])
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
# time-shift
mplot <- Arg(t(sign(apply(mdfa_obj$b, 2, sum)) * t(mdfa_obj$trffkt))) /
      ((0 : (nrow(mdfa_obj$trffkt) - 1)) * pi / (nrow(mdfa_obj$trffkt) - 1))
# We use the exact formula for the time-shift in frequency zero
mplot[1, ] <- apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum)
plot_title <- "Time-Shift"
mplot_func(mplot, ax, plot_title, title_more, insamp, colo)
dev.off()
print(c("Time-shift restrictions",round(apply(mdfa_obj$b*(0:(L-1)),2,sum)/apply(mdfa_obj$b, 2, sum),4)))


###################################################
### code chunk number 72: z_mdfa_ar1_amp_shift_Lag_0_iF_i2T_Lag.pdf
###################################################
  file = paste("z_mdfa_ar1_amp_shift_Lag_0_iF_i2T_Lag.pdf", sep = "")
  cat("\\begin{figure}[H]")
  cat("\\begin{center}")
  cat("\\includegraphics[height=6in, width=6in]{", file, "}\n",sep = "")
  cat("\\caption{Amplitude (top) and time-shift (bottom) functions: i1=F,i2=T, Lag=-2", sep = "")
  cat("\\label{z_mdfa_ar1_amp_shift_Lag_0_iF_i2T_Lag}}", sep = "")
  cat("\\end{center}")
  cat("\\end{figure}")


###################################################
### code chunk number 73: exercise_dfa_ms_4
###################################################
len_t<-100
# Generate two linear trends (the are shifted by a constant in order to be distinguishable)
trend_data<-cbind(1:len_t,0.5+1:len_t)
# Compute both output series: normalize by the inverse transferfunctions in frequency zero
yhat_multivariate<-cbind(rep(NA,len_t),rep(NA,len_t))
for (i in 1:ncol(yhat_multivariate))
  for (j in L:len_t)
#  The transfer function in frequency zero is a real number: R computes a complex number
#  with vanishing imaginary part. We have to extract the real part because otherwise the complex 
#  series would not be plotted... 
    yhat_multivariate[j,i]<-sum(b_mat[,i]*trend_data[j:(j-L+1),i])/Re(trffkt_mdfa[1,i])
# Plot the series
mplot<-cbind(trend_data,yhat_multivariate)
dimnames(mplot)[[2]]<-c("Input 1","Input 2","Filter output 1","Filter output 2")
insamp <- 1.e+90
colo <- NULL
plot_title <- "Filter Outputs vs. Input Signal"
title_more <- colnames(x[, -1])
ax<-NULL
#mplot_func(mplot[50:60,], ax, plot_title, title_more, insamp, colo)
# Display the last observations
tail(mplot)


###################################################
### code chunk number 74: dfa_analytic
###################################################

# This function computes analytic DFA-solutions
# L is the length of the MA-filter,
# weight_func is the periodogram,
# lambda emphasizes phase artifacts in the customized criterion,
# eta emphasizes noise-suppression/smoothness
# Gamma is the transferfunction of the symmetric filter (target) and
# Lag is the lag-parameter: Lag=0 implies real-time filtering, Lag=L/2
#     implies symmetric filter
# i1 and i2 allow for filter restrictions in frequency zero
# The function returns the weights of the MA-Filter as well as its transferfunction
#
#
dfa_analytic<-function(L,lambda,weight_func,Lag,Gamma,eta,cutoff,i1,i2)
{
  K<-length(weight_func)-1
# Define the amplitude weighting function weight_h (W(omega_k))
  omega_Gamma<-as.integer(cutoff*K/pi)
  if ((K-omega_Gamma+1)>0)
  {
    weight_h<-weight_func*(c(rep(1,omega_Gamma),(1:(K-omega_Gamma+1))^(eta)))
  } else
  {
    weight_h<-weight_func*rep(1,K+1)
  }
# First order filter restriction: assigning a large weight to frequency zero
  if (i1)
    weight_h[1]<-max(1.e+10,weight_h[1])

  X<-exp(-1.i*Lag*pi*(0:(K))/(K))*rep(1,K+1)*sqrt(weight_h)
  X_y<-exp(-1.i*Lag*pi*(0:(K))/(K))*rep(1,K+1)
  if (i2)
  {
# Second order restriction: time shift in frequency zero vanishes
    for (l in 2:(L-1))
    {
      X<-cbind(X,(cos((l-1-Lag)*pi*(0:(K))/(K))-((l-1)/(L-1))*
      cos((L-1-Lag)*pi*(0:(K))/(K))+
      sqrt(1+Gamma*lambda)*1.i*(sin((l-1-Lag)*pi*(0:(K))/(K))-((l-1)/(L-1))*
      sin((L-1-Lag)*pi*(0:(K))/(K))))*sqrt(weight_h))
      X_y<-cbind(X_y,(cos((l-1-Lag)*pi*(0:(K))/(K))-((l-1)/(L-1))*
      cos((L-1-Lag)*pi*(0:(K))/(K))+
      1.i*(sin((l-1-Lag)*pi*(0:(K))/(K))-((l-1)/(L-1))*sin((L-1-Lag)*pi*(0:(K))/(K)))))
    }
    xtx<-t(Re(X))%*%Re(X)+t(Im(X))%*%Im(X)
  # MA-Filterweights
    b<-as.vector(solve(xtx)%*%(t(Re(X_y))%*%(Gamma*weight_h)))
# the last weight is a function of the previous ones through the second order restriction
    b<-c(b,-sum(b*(0:(length(b)-1)))/(length(b)))
  } else
  {
    for (l in 2:L)
    {
      X<-cbind(X,(cos((l-1-Lag)*pi*(0:(K))/(K))+
      sqrt(1+Gamma*lambda)*1.i*sin((l-1-Lag)*pi*(0:(K))/(K)))*sqrt(weight_h))
      X_y<-cbind(X_y,(cos((l-1-Lag)*pi*(0:(K))/(K))+
      1.i*sin((l-1-Lag)*pi*(0:(K))/(K))))
    }
    xtx<-t(Re(X))%*%Re(X)+t(Im(X))%*%Im(X)
  # MA-Filterweights
    b<-as.vector(solve(xtx)%*%(t(Re(X_y))%*%(Gamma*weight_h)))
  }
  # Transferfunction
  trffkt<-1:(K+1)
  trffkt[1]<-sum(b)
  for (k in 1:(K))#k<-1
  {
    trffkt[k+1]<-(b%*%exp(1.i*k*(0:(length(b)-1))*pi/(K)))
  }
  return(list(b=b,trffkt=trffkt))
}


